<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ReTest.jl · ReTest.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ReTest.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>ReTest.jl</a><ul class="internal"><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#Quick-start"><span>Quick start</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li><li><a class="tocitem" href="#Caveats"><span>Caveats</span></a></li><li><a class="tocitem" href="#Switching-from-Test-to-ReTest"><span>Switching from <code>Test</code> to <code>ReTest</code></span></a></li><li><a class="tocitem" href="#Filtering"><span>Filtering</span></a></li><li><a class="tocitem" href="#Running-tests-in-parallel-with-Distributed"><span>Running tests in parallel with <code>Distributed</code></span></a></li><li><a class="tocitem" href="#Working-with-Revise"><span>Working with <code>Revise</code></span></a></li><li><a class="tocitem" href="#Working-with-test-files-which-use-Test"><span>Working with test files which use <code>Test</code></span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>ReTest.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ReTest.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaTesting/ReTest.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ReTest.jl"><a class="docs-heading-anchor" href="#ReTest.jl">ReTest.jl</a><a id="ReTest.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ReTest.jl" title="Permalink"></a></h1><p><code>ReTest</code> is a testing framework for Julia allowing:</p><ol><li><p>Defining tests in source files, whose execution is deferred and triggered on demand.</p><p>This is useful when one likes to have definitions of methods and corresponding tests close to each other. This is also useful for code which is not (yet) organized as a package, and where one doesn&#39;t want to maintain a separate set of files for tests.</p></li><li><p>Filtering run testsets with a <code>Regex</code>, which is matched against the descriptions of testsets.</p><p>This is useful for running only part of the test suite of a package. For example, if you made a change related to addition, and included &quot;addition&quot; in the description of the corresponding testsets, you can easily run only these tests.</p><p>Note that a <a href="https://github.com/JuliaLang/julia/pull/33672">pull request</a> exists in the Julia repository to implement regex-filtering for <code>Test.@testset</code>.</p></li></ol><p>A couple more features are also enabled, like shuffling the order in which the testsets are run, or running testsets in parallel (via <code>Distributed</code>).</p><p><code>ReTest</code> is mostly backward-compatible with <code>Test</code>, i.e. minimal change to test files is necessary in order to switch to <code>ReTest</code>; it&#39;s often even possible to use <code>ReTest</code> features without changing a line, e.g. on Julia&#39;s <code>Base</code>/stdlib tests), cf. <a href="#Working-with-test-files-which-use-Test">Working with test files which use <code>Test</code></a>.</p><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><p>The exported <a href="#InlineTest.@testset"><code>ReTest.@testset</code></a> macro can be used as a direct replacement for <code>Test.@testset</code> (with limitations, <a href="#Caveats">see below</a>), and <code>retest()</code> has to be called for the tests to be executed. See <a href="#InlineTest.retest"><code>retest</code></a>&#39;s docstrings for more details. Moreover, <code>ReTest</code> re-exports (almost) all exported symbols from <code>Test</code>, so there should not be any need to import <code>Test</code> together with <code>ReTest</code>.</p><p>When using <code>@testset</code> &quot;inline&quot;, i.e. within the source-code of a package, one can use the <code>InlineTest</code> package instead of <code>ReTest</code>, which only defines the strict minimum and also exports <code>@testset</code>, and therefore loads faster (even if <code>ReTest</code> itself loads fast, it can be desirable to have an even lighter dependency). But <code>ReTest</code> still has to be loaded (as a &quot;test&quot; dependency) in order to call <code>retest</code>.</p><p>Finally, for convenience, <code>ReTest.@testset</code> also implicitly defines a <code>runtests</code> function within the enclosing module (and within all recursive parent modules), say <code>M</code>, such that <code>M.runtests(...)</code> is equivalent to calling <code>retest(M, ...)</code>.</p><h2 id="Quick-start"><a class="docs-heading-anchor" href="#Quick-start">Quick start</a><a id="Quick-start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-start" title="Permalink"></a></h2><p>Both <code>ReTest</code> and <code>InlineTest</code> are registered packages and can be installed the usual way. Let&#39;s create a package <code>MyPackage</code>, which is initially a single file located in a directory known to <code>LOAD_PATH</code>. We want to test its <code>greet</code> function, by writing tests directly in the same file; this is a use-case for <code>InlineTest</code>, which loads faster than <code>ReTest</code>:</p><pre><code class="language-julia"># MyPackage.jl file

module MyPackage
using InlineTest

greet() = &quot;Hello World!&quot;

@testset &quot;greet&quot; begin
    @test greet() == &quot;Hello World!&quot;
end

end # module</code></pre><p>Now, in a Julia session, we load <code>MyPackage</code> and <code>ReTest</code> (needed to actually run the tests):</p><pre><code class="language-julia">julia&gt; using MyPackage, ReTest

julia&gt; MyPackage.runtests()
               Pass
MyPackage:
  greet    |      1</code></pre><p>Suppose now that we organize <code>MyPackage</code> as a standard package, with a proper &quot;runtests.jl&quot; file. We can still keep testsets within &quot;MyPackage.jl&quot;, while adding more thorough tests in the &quot;test&quot; folder, which can contain two files, &quot;runtests.jl&quot; and &quot;MyPackageTests.jl&quot;:</p><pre><code class="language-julia"># MyPackage/test/runtests.jl file

using ReTest, MyPackage
include(&quot;MyPackageTests.jl&quot;)

# when including this file (e.g. with `Pkg.test`), all the tests
# in both modules will be run:

retest(MyPackage, MyPackageTests)</code></pre><pre><code class="language-julia"># MyPackage/test/MyPackageTests.jl file

module MyPackageTests
using MyPackage, ReTest

@testset &quot;more greet&quot; begin
    @testset &quot;concatenation&quot; begin
        @test MyPackage.greet()^2 == &quot;Hello World!Hello World!&quot;
    end
end

@testset &quot;stuff&quot; begin
    @test true
end

end # module</code></pre><p>We can now load tests either via <code>using MyPackageTests</code>, if <code>LOAD_PATH</code> is configured appropriately, or via <code>include</code>, and run whichever tests we want:</p><pre><code class="language-julia">julia&gt; include(&quot;test/MyPackageTests.jl&quot;);

julia&gt; using ReTest # to use the `retest` function

julia&gt; retest(dry=true, verbose=2) # just list tests, showing nested ones
MyPackage
1| greet

Main.MyPackageTests
1| more greet
2|   concatenation
3| stuff

julia&gt; retest(&quot;greet&quot;, verbose=2) # run only tests related to `greet()`
                         Pass
MyPackage:
  greet              |      1

Main.MyPackageTests:
  more greet         |      1
    concatenation    |      1

Overall              |      2

julia&gt; MyPackageTests.runtests(3) # run only testset with ID 3 in MyPackageTests
                            Pass
   Main.MyPackageTests:
3|   stuff              |      1</code></pre><p>Here it is for basic usage!</p><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><ul><li><a href="#InlineTest.retest"><code>retest</code></a></li><li><a href="#ReTest.not"><code>not</code></a></li><li><a href="#ReTest.interpolated"><code>interpolated</code></a></li><li><a href="#ReTest.reachable"><code>reachable</code></a></li><li><a href="#ReTest.depth"><code>depth</code></a></li><li><a href="#InlineTest.@testset"><code>@testset</code></a></li><li><a href="#InlineTest.@testset_macro"><code>@testset_macro</code></a></li><li><a href="#ReTest.load"><code>load</code></a></li><li><a href="#ReTest.watch"><code>watch</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="InlineTest.retest" href="#InlineTest.retest"><code>InlineTest.retest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">retest(mod..., pattern...;
       dry::Bool=false, stats::Bool=false, verbose::Real=true,
       [id::Bool], shuffle::Bool=false, recursive::Bool=true,
       static::Union{Bool,Nothing}=nothing, dup::Bool=false,
       load::Bool=false, [seed::Integer])</code></pre><p>Run tests declared with <a href="#InlineTest.@testset"><code>@testset</code></a> blocks, within modules <code>mod</code> if specified, or within all currently loaded modules otherwise. When no <code>pattern</code>s are specified, all the tests are run.</p><p><strong>Keywords</strong></p><ul><li>If <code>dry</code> is <code>true</code>, don&#39;t actually run the tests, just print the descriptions of the testsets which would (presumably) run.</li><li>If <code>stats</code> is <code>true</code>, print some time/memory statistics for each testset.</li><li>If specified, <code>verbose</code> must be an integer or <code>Inf</code> indicating the nesting level of testsets whose results must be printed (this is equivalent to adding the <code>verbose=true</code> annotation to corresponding testsets); the default behavior (<code>true</code> or <code>1</code>) corresponds to printing the result of top-level testsets.</li><li>If <code>id</code> is <code>true</code>, a unique (per module) integer ID is printed next to each testset, which can be used for filtering. The default value of <code>id</code> depends on other options.</li><li>If <code>shuffle</code> is <code>true</code>, shuffle the order in which top-level testsets within a given module are run, as well as the list of passed modules.</li><li>If <code>recursive</code> is <code>true</code>, the tests for all the recursive submodules of the passed modules <code>mod</code> are also run.</li><li>The <code>static</code> keyword controls testsets filtering: if <code>true</code>, only testsets which are known to match &quot;statically&quot; the passed patterns, i.e. at filtering time, are run. See docstring of <a href="#ReTest.interpolated"><code>interpolated</code></a> for more details.</li><li>If <code>dup</code> is <code>true</code>, multiple toplevel testsets can have the same description. If <code>false</code>, only the last testset of a &quot;duplicate group&quot; is kept. The default is <code>false</code> in order to encourage having unique descriptions (useful for filtering) but also and mostly to play well with <code>Revise</code>. This keyword applies only to newly added testsets since the last run.</li><li>When <code>load</code> is <code>true</code>, for each package module <code>Mod</code> which is selected, <code>retest</code> attempts to also select a corresponding <code>Main.ModTests</code> module with the same pattern specification, unless such module is already explicitly passed as an argument. If this test module doesn&#39;t already exist, <code>retest</code> attempts first to include into <code>Main</code> the corresponding test file &quot;test/ModTests.jl&quot; which is assumed, if it exists, to define one or more test modules (typically <code>ModTests</code>); these new test modules are associated to <code>Mod</code> (they inherit its pattern specification as above), and are cached and used again on subsequent invocations.</li><li>If <code>seed</code> is provided, it is used to seed the global RNG before running the tests.</li></ul><p><strong>Filtering</strong></p><p>It&#39;s possible to filter run testsets by specifying one or multiple <code>pattern</code>s. A testset is guaranteed to run only if it &quot;matches&quot; all passed patterns (conjunction). Even if a testset is run, its nested testsets might not run if they don&#39;t match the patterns. Moreover if a testset is run, its enclosing testset, if any, also has to run (although not necessarily exhaustively, i.e. other nested testsets might be filtered out).</p><p>A <code>pattern</code> can be a string, a <code>Regex</code>, an integer, an array or a tuple. For a testset to &quot;match&quot; an array, it must match at least one of its elements (disjunction). To match a tuple, it must match all of its elements (conjunction). To match an integer, its ID must be equal to this integer (cf. the <code>id</code> keyword).</p><p>A pattern can also be the &quot;negation&quot; of a pattern, via the <a href="#ReTest.not"><code>not</code></a> function, which allows to exclude testsets from being run. As a special case, the negation of an integer can be expressed as its arithmetic negation, e.g. <code>not(3)</code> is equivalent to <code>-3</code>.</p><p>Patterns can also be created via <a href="#ReTest.reachable"><code>reachable</code></a>, <a href="#ReTest.interpolated"><code>interpolated</code></a> and <a href="#ReTest.depth"><code>depth</code></a>.</p><p><strong><code>Regex</code> filtering</strong></p><p>The &quot;subject&quot; of a testset is the concatenation of the subject of its parent <code>@testset</code>, if any, with <code>&quot;/$description&quot;</code> where <code>description</code> is the testset&#39;s description. For example:</p><pre><code class="language-julia">@testset &quot;a&quot; begin # subject == &quot;/a&quot;
    @testset &quot;b&quot; begin # subject is &quot;/a/b&quot;
    end
    @testset &quot;c$i&quot; for i=1:2 # subjects are &quot;/a/c1&quot; &amp; &quot;/a/c2&quot;
    end
end</code></pre><p>When <code>pattern</code> isa a <code>Regex</code>, a testset is guaranteed to run only when its subject  matches <code>pattern</code>. Moreover, even if a testset matches (e.g. &quot;/a&quot; above with <code>pattern == r&quot;a$&quot;</code>), its nested testsets might be filtered out if they don&#39;t also match (e.g. &quot;a/b&quot; doesn&#39;t match <code>pattern</code>).</p><p>If a passed <code>pattern</code> is a string, then it is wrapped in a <code>Regex</code> with the &quot;case-insensitive&quot; flag, and must match literally the subjects. This means for example that <code>&quot;a|b&quot;</code> will match a subject like <code>&quot;a|b&quot;</code> or <code>&quot;A|B&quot;</code>, but not like <code>&quot;a&quot;</code> (only in Julia versions &gt;= 1.3; in older versions, the regex is simply created as <code>Regex(pattern, &quot;i&quot;)</code>).</p><p>As a special case, if a string pattern starts with the <code>&#39;-&#39;</code> character, it&#39;s interpreted as the negation of the pattern corresponding to the string with <code>&#39;-&#39;</code> chopped off, e.g. <code>&quot;-abc&quot;</code> is equivalent to <code>not(&quot;abc&quot;)</code>. Unless the string starts with two <code>&#39;-&#39;</code> characters, in which case the first <code>&#39;-&#39;</code> is chopped off, e.g. <code>&quot;--abc&quot;</code> will match subjects such as <code>&quot;123-abc&quot;</code>. To negate such a pattern, just use <code>not</code>, e.g. <code>not(&quot;--abc&quot;)</code>.</p><p><strong>Per-module patterns</strong></p><p>In addition to modules or patterns, positional arguments of <code>retest</code> can also be a pair of the form <code>mod =&gt; pattern</code>: then <code>pattern</code> is used to filter only testsets from <code>mod</code>; if other &quot;standalone&quot; patterns (not attached to a module) are specified, they also conjunctively apply to <code>mod</code>. For example, a call like <code>retest(mod1 =&gt; 1:3, mod2, &quot;x&quot;)</code> is equivalent to <code>retest(mod1 =&gt; (1:3, &quot;x&quot;), mod2 =&gt; &quot;x&quot;)</code>. If <code>recursive</code> is <code>true</code>, <code>pattern</code> is also applied to all recursive submodules <code>sub</code> of <code>mod</code>; if <code>sub</code> is also specified as <code>sub =&gt; subpat</code>, the patterns are merged, i.e. this is equivalent to specifying <code>sub =&gt; (pattern, subpat)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>this function executes each (top-level) <code>@testset</code> block using <code>eval</code> <em>within</em> the module in which it was written (e.g. <code>mod</code>, when specified).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/ecf4624849d1e7b5edb9ee7b99e9f37f19a2a8a8/src/ReTest.jl#L453-L572">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReTest.not" href="#ReTest.not"><code>ReTest.not</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">not(pattern)</code></pre><p>Create an object suitable for filtering testsets (in the <a href="#InlineTest.retest"><code>retest</code></a> function), which &quot;negates&quot; the meaning of <code>pattern</code>: a testset matches <code>not(pattern)</code> if and only if it doesn&#39;t match <code>pattern</code>.</p><p>For example <code>not(&quot;a&quot;)</code> matches any testset whose subject doesn&#39;t contain <code>&quot;a&quot;</code>, and <code>not(1:3)</code> matches all the testsets but the first three of a module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/ecf4624849d1e7b5edb9ee7b99e9f37f19a2a8a8/src/patterns.jl#L163-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReTest.interpolated" href="#ReTest.interpolated"><code>ReTest.interpolated</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">interpolated</code></pre><p>Singleton pattern which matches any testset whose subject can be interpolated &quot;statically&quot;, i.e. at filtering time before testset are actually run. Non-inferrable subjects include those constructed from descriptions containing interpolated values which can&#39;t be known until run time. This pattern has an effect closely related to that of the <code>static</code> keyword of <a href="#InlineTest.retest"><code>retest</code></a>, discussed below, which is probably more generally useful.</p><p><strong>Examples</strong></p><p>Given these testset:</p><pre><code class="language-julia">@testset &quot;outer&quot; verbose=true begin
    @test true
    inner = &quot;inner&quot;
    @testset &quot;$inner&quot; begin
        @test true
    end
end
@testset &quot;other&quot; begin
    @test true
end</code></pre><p>We get:</p><pre><code class="language-julia">julia&gt; retest(&quot;other&quot;, dry=true)
Main
1| outer
2|   &quot;$(inner)&quot;
3| other

julia&gt; retest(&quot;other&quot;, dry=false)
            Pass
outer   |      1
other   |      1
Main    |      2

julia&gt; retest(&quot;other&quot;, dry=true, interpolated)
Main
3| other</code></pre><p>Without <code>interpolated</code>, <code>retest</code> can&#39;t decide at filtering time whether the &quot;inner&quot; testset will run, so must mark the &quot;outer&quot; testset as having to run. At run time, &quot;inner&quot; is not run because it doesn&#39;t match the pattern, but &quot;outer&quot; still had to run to determine this. With the <code>interpolated</code> pattern, &quot;inner&quot; is filtered out and <code>retest</code> selects only testsets which are statically known to have to run.</p><p>So again, <code>interpolated</code> doesn&#39;t have the same effect at filtering time (like when <code>dry=true</code>) and at run time. For example, one can see the list of non-interpolated subjects as follows with <code>dry=true</code>, but not run them (because everything is interpolated at run time):</p><pre><code class="language-julia">julia&gt; retest(not(interpolated), dry=true)
1| outer
2|   &quot;$(inner)&quot;

julia&gt; retest(not(interpolated), dry=false)
            Pass
Main:
  outer |      1</code></pre><p><strong><code>static</code> keyword</strong></p><p>Unlike <code>interpolated</code>, the <code>static</code> keyword of <code>retest</code>, when <code>true</code>, filters out only testsets which can&#39;t be proven to have to run at filtering time, let&#39;s call them &quot;undecidable&quot;. It can have sometimes the same effect as when using <code>interpolated</code>, e.g. <code>retest(&quot;other&quot;, dry=true, static=true)</code> and <code>retest(&quot;other&quot;, dry=true, interpolated)</code> give the same result.</p><p>But in some cases we might want to filter out noisy testsets whose subjects can&#39;t be interpolated, but still include those which are relevant. For example, assume we want to run testsets <code>1</code> and <code>2</code>, while excluding other testsets with uninterpolated subjects:</p><pre><code class="language-julia">julia&gt; retest(1:2, dry=true, interpolated)
Main
1| outer

julia&gt; retest(1:2, dry=true, static=true)
Main
1| outer
2|   &quot;$(inner)&quot;</code></pre><p>The solution with <code>interpolated</code> is not what we want, as we specifically want testset <code>2</code> to run. Given the filtering specifications (<code>1:2</code> here), the filtering algorithm can determine that <code>2</code> should run even though its subject is unknown at this point.</p><p>Given a filtering specification, there are three kind of testsets:</p><ul><li>&quot;undecidable&quot; (see above)</li><li>&quot;match&quot;: they are known statically to have to run</li><li>&quot;nomatch&quot;: they are known statically to not have to run</li></ul><p>The default value of the <code>static</code> keyword is <code>nothing</code>, which means to run testsets which are not known with certainty to not match, i.e. &quot;match&quot; and &quot;undecidable&quot; testsets. As seen above, when <code>static == true</code>, only &quot;match&quot; testsets are run. When <code>static == false</code>, the behavior is the opposite: only &quot;undecidable&quot; testsets are run. Of course, other combinations involving &quot;nomatch&quot; testsets can be had by reversing the filtering pattern via <a href="#ReTest.not"><code>not</code></a>.</p><p>For example, to get the equivalent to the <code>not(interpolated)</code> example above, but with an effect which persists at run time (<code>dry = false</code>), you can use <code>static = false</code> together with the match-all regex pattern <code>r&quot;.*&quot;</code>, which will mark the <code>&quot;inner&quot;</code> testset as &quot;undecidable&quot; (the algorithm inspects slightly patterns just to recognize the simple match-all patterns <code>&quot;&quot;</code> and <code>r&quot;&quot;</code>, but won&#39;t detect that <code>r&quot;.*&quot;</code> would match <code>&quot;$(inner)&quot;</code>):</p><pre><code class="language-julia">julia&gt; retest(r&quot;.*&quot;, static=false, dry=true)
Main
1| outer
2|   &quot;$(inner)&quot;

julia&gt; retest(r&quot;.*&quot;, static=false, dry=false)
               Pass
Main:
  outer    |      2
    inner  |      1</code></pre><p>One example of a rare case where a given testset is not in a single of the above three categories is as follows:</p><pre><code class="language-julia">@testset &quot;a&quot; begin
    x = 2
    @testset &quot;b$(i==1 ? 1 : x)&quot; for i=1:2
        @testset &quot;c&quot; begin
            # subject is &quot;match&quot; at first iteration and
            # &quot;undecidable&quot; at second iteration
            @test true
        end
    end
end</code></pre><p>One thing to understand is that the &quot;identity&quot; of a testset is determined by a given occurrence of the <code>@testset</code> macro. In the example above, for either the patterns &quot;b&quot; or &quot;c&quot;, the two inner testsets are both &quot;match&quot; and &quot;undecidable&quot;. In this case, the filtering algorithm selects a testset to run if at least one iteration would lead to this decision. Here, if <code>static=true</code> the first iteration would run, and if <code>static=false</code> the second iteration would run. This results in the same selection whatever the value of <code>static</code> is.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/ecf4624849d1e7b5edb9ee7b99e9f37f19a2a8a8/src/patterns.jl#L176-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReTest.reachable" href="#ReTest.reachable"><code>ReTest.reachable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reachable(pattern)</code></pre><p>Create a filtering pattern which matches any testset matching <code>pattern</code> or whose parent testset, if any, matches <code>reachable(pattern)</code>. In other words, if a testset matches <code>pattern</code>, all its recursive nested testsets will also match.</p><p>When <code>pattern::String</code>, <code>reachable(pattern)</code> has the same effect as <code>pattern</code>, because the subject of a testset is contained in the subjects of all its nested testsets. So <code>reachable</code> is typically useful when <code>pattern</code> is an integer.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; module T
       using ReTest
       @testset &quot;a&quot; verbose=true begin
           @test true
           @testset &quot;b&quot; begin
               @test true
           end
       end
       @testset &quot;c&quot; begin
           @test true
       end
       end;

julia&gt; retest(T, reachable(1), dry=true)
1| a
2|   b

julia&gt; retest(T, not(reachable(1)), dry=true)
3| c</code></pre><p>Note that the algorithm for <code>reachable</code> is currently not optimized, i.e. it will match <code>pattern</code> against all parents of a testset until success, even when this match was already performed earlier (i.e. the result of matching against <code>pattern</code> is not cached).</p><p>Also, in the current implementation, the subject of a parent testset is inferred from the subject of a testset, by chopping off the last component, determined by the last occurrence of <code>&#39;/&#39;</code>. This has two consequences. It will produce incorrect results if the description of a testset contains <code>&#39;/&#39;</code>, and also, with <a href="#ReTest.interpolated"><code>interpolated</code></a> when the subject is &quot;unknown&quot; due to un-interpolated descriptions. Consider the following example:</p><pre><code class="language-julia">julia&gt; module Fail
       using ReTest
       @testset &quot;a&quot; begin
           x = 1
           @testset &quot;b$x&quot; begin
               @testset &quot;c&quot; begin end
           end
       end
       end;

julia&gt; retest(Fail, reachable(1), verbose=9, dry=true)
1| a
2|   &quot;b$(x)&quot;
3|     c

julia&gt; retest(Fail, reachable(interpolated), verbose=9, dry=true)
1| a</code></pre><p>Here, both testsets with id <code>2</code> and <code>3</code> have an unknown subject (at filtering time), which prevents the algorithm to detect that one of their parents (testset <code>1</code>) actually has an &quot;interpolated&quot; description.</p><p>On the other hand, even with these unknown subjects, something like <code>reachable(&quot;a&quot;)</code> would work as expected:</p><pre><code class="language-julia">julia&gt; retest(Fail, reachable(&quot;a&quot;), verbose=9, dry=true)
1| a
2|   &quot;b$(x)&quot;
3|     c

julia&gt; retest(Fail, reachable(&quot;a&quot;), verbose=9, dry=true, static=true)
1| a</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This function requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/ecf4624849d1e7b5edb9ee7b99e9f37f19a2a8a8/src/patterns.jl#L333-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReTest.depth" href="#ReTest.depth"><code>ReTest.depth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">depth(d::Integer)</code></pre><p>Create a pattern which matches testsets at &quot;depth&quot; <code>d</code>. Toplevel testsets have depth <code>1</code>, their direct children (nested testsets) depth <code>2</code>, and so on.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; module Depth
       using ReTest
       @testset &quot;1&quot; begin
           @testset &quot;2&quot; begin
               @testset &quot;3&quot; begin end
           end
           @testset &quot;4&quot; begin end
       end
       end;

julia&gt; Depth.runtests(dry=true, verbose=3, depth(2))
1| 1
2|   2
4|   4

julia&gt; Depth.runtests(dry=true, verbose=3, depth(3))
1| 1
2|   2
3|     3

julia&gt; Depth.runtests(dry=true, verbose=3, reachable(depth(2)))
1| 1
2|   2
3|     3
4|   4

julia&gt; Depth.runtests(dry=true, verbose=3, depth.(2:3))
1| 1
2|   2
3|     3
4|   4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/ecf4624849d1e7b5edb9ee7b99e9f37f19a2a8a8/src/patterns.jl#L427-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InlineTest.@testset" href="#InlineTest.@testset"><code>InlineTest.@testset</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@testset args...</code></pre><p>Similar to <code>Test.@testset args...</code>, but the contained tests are not run immediately, and are instead stored for later execution, triggered by <a href="#InlineTest.retest"><code>retest()</code></a> or <code>runtests()</code>. Invocations of <code>@testset</code> can be nested, but qualified invocations of <code>ReTest.@testset</code> can&#39;t. Internally, <code>@testset</code> expressions are converted to an equivalent of <code>Test.@testset</code> at execution time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/ecf4624849d1e7b5edb9ee7b99e9f37f19a2a8a8/InlineTest/src/InlineTest.jl#L48-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="InlineTest.@testset_macro" href="#InlineTest.@testset_macro"><code>InlineTest.@testset_macro</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@testset_macro @mac</code></pre><p>Declare <code>@mac</code> as a macro which must be expanded statically by <code>retest</code> so that contained <code>@testset</code>s can be discovered.</p><p>Consider this pattern with <code>Test</code> which factors out testsets in a function:</p><pre><code class="language-julia">using Test

function test_iseven(x)
    @testset &quot;iseven $x&quot; begin
        @test iseven(x)
    end
end

@testset &quot;test $x&quot; for x=2:2:4
    test_iseven(x)
end</code></pre><p>This doesn&#39;t translate directly with <code>ReTest</code>, as the call to <code>test_iseven</code> will be performed at run-time, and will end up declaring a new <code>@testset &quot;iseven $x&quot;</code> at toplevel (this is a problem similar to having <code>include</code> inside testsets). So on the first run of <code>retest()</code>, no <code>@test</code> is run, and on the second one, it fails because <code>x</code> is not defined at global scope.</p><p>The alternative is to turn <code>test_iseven</code> into a macro and declare it with <code>@testset_macro</code>:</p><pre><code class="language-julia">using ReTest

macro test_iseven(x)
    quote
        @testset &quot;iseven $($x)&quot; begin
            @test iseven($x)
        end
    end
end

@testset_macro @test_iseven

@testset &quot;test $x&quot; for x=2:2:4
    @test_iseven(x)
end</code></pre><p>Then, running <code>retest(&quot;iseven&quot;, verbose=2)</code> gives:</p><pre><code class="language-none">                    Pass
test 2          |      1
  iseven 2      |      1
test 4          |      1
  iseven 4      |      1
Main            |      2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/ecf4624849d1e7b5edb9ee7b99e9f37f19a2a8a8/InlineTest/src/InlineTest.jl#L103-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReTest.load" href="#ReTest.load"><code>ReTest.load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ReTest.load(testpath::AbstractString;
            parentmodule::Module=Main, [revise::Bool])</code></pre><p>Include file <code>testpath</code> into <code>parentmodule</code>. If <code>revise</code> is <code>true</code>, <code>Revise</code>, which must be loaded beforehand in your Julia session, is used to track all recursively included files (in particular testsets). The <code>revise</code> keyword defaults to <code>true</code> when <code>Revise</code> is loaded and <code>VERSION &gt;= v&quot;1.5&quot;</code>, and to <code>false</code> otherwise.</p><p>The point of using this function is when <code>revise</code> is <code>true</code> and in particular when files are included recursively. If <code>revise</code> is false, this is equivalent to <code>parentmodule.include(testpath)</code>, and if there are no recursively included files, this should be equivalent to <code>Revise.includet(testpath)</code>, provided <code>parentmodule == Main</code> and all <code>@testset</code>s defined in <code>testpath</code> are in a module defining  <code>__revise_mode__ = :eval</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>This function requires at least Julia 1.5 when <code>revise</code> is <code>true</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/ecf4624849d1e7b5edb9ee7b99e9f37f19a2a8a8/src/hijack.jl#L1-L21">source</a></section><section><div><pre><code class="language-none">ReTest.load(Mod::Module, testfile::AbstractString=&quot;ModTests.jl&quot;;
            parentmodule::Module=Main, [revise::Bool])</code></pre><p>Given a package <code>Mod</code>, include into <code>parentmodule</code> the corresponding tests from file <code>testfile</code>, which is assumed to be located in the &quot;test&quot; directory of the package. It is expected that a unique new test module is created within <code>parentmodule</code> after the inclusion, which is then returned. Otherwise, the list of all newly created test modules is returned, triggering a warning if it&#39;s empty.</p><p>If <code>revise</code> is <code>true</code>, <code>Revise</code>, which must be loaded beforehand in your Julia session, is used to track the test files (in particular testsets). Note that this might be brittle, and it&#39;s recommended instead to load your test module via <code>using ModTests</code>. The <code>revise</code> keyword defaults to <code>true</code> when <code>Revise</code> is loaded and <code>VERSION &gt;= v&quot;1.5&quot;</code>, and to <code>false</code> otherwise.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>This function requires at least Julia 1.5 when <code>revise</code> is <code>true</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/ecf4624849d1e7b5edb9ee7b99e9f37f19a2a8a8/src/hijack.jl#L40-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReTest.watch" href="#ReTest.watch"><code>ReTest.watch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ReTest.watch(args...; kwargs...)</code></pre><p>Run <code>retest(args...; kwargs...)</code> repeatedly each time <code>Revise</code> detects file updates. <code>Revise</code> must be loaded beforehand in your Julia session.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This experimental function is not tested and is currently very basic.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/ecf4624849d1e7b5edb9ee7b99e9f37f19a2a8a8/src/watch.jl#L1-L9">source</a></section></article><h2 id="Caveats"><a class="docs-heading-anchor" href="#Caveats">Caveats</a><a id="Caveats-1"></a><a class="docs-heading-anchor-permalink" href="#Caveats" title="Permalink"></a></h2><p><code>ReTest.@testset</code> comes with a couple of caveats/limitations, some of which should be fixable:</p><ul><li><p>Toplevel testsets (which are not nested within other testsets), when run, are <code>eval</code>ed at the toplevel of their parent module, which means that they can&#39;t depend on local variables for example.</p></li><li><p>&quot;testsets-for&quot; (<code>@testset &quot;description&quot; for ...</code>), when run, imply <code>eval</code>ing their loop variables at the toplevel of their parent module; this implies that iteration expressions shouldn&#39;t depend on local variables (otherwise, the testset subject usually can&#39;t be known statically and the testset can&#39;t be filtered out with a <code>Regex</code>).</p></li><li><p>Testsets can not be &quot;custom testsets&quot; (cf. <code>Test</code> documentation).</p></li><li><p>Nested testsets can&#39;t be &quot;qualified&quot; (i.e. written as <code>ReTest.@testset</code>).</p></li><li><p>Regex filtering logic might improve in future versions, which means that with the same regex, less tests might be run (or more!). See <a href="#InlineTest.retest"><code>retest</code></a>&#39;s docstring to know which testsets are guaranteed to run.</p></li><li><p>Descriptions of testsets must be unique within a module, otherwise they are overwritten and a warning is issued, unless <code>Revise</code> is loaded; the reason is the current implemented heuristic to allow <code>Revise</code> do its magic.</p></li></ul><h4 id="Including-files-from-within-testsets"><a class="docs-heading-anchor" href="#Including-files-from-within-testsets">Including files from within testsets</a><a id="Including-files-from-within-testsets-1"></a><a class="docs-heading-anchor-permalink" href="#Including-files-from-within-testsets" title="Permalink"></a></h4><p>TLDR: don&#39;t use <code>include(file)</code> within testsets when <code>file</code> defines other testsets.</p><p>There is limited support for <code>include(path)</code> expressions within testsets: all what <code>ReTest</code> does is to adjust the <code>path</code> according to the location of the containing file <code>parentfile</code>. This is necessary, because <code>include</code> is not run immediately when that file is evaluated; when the given testset is triggered (via a <code>retest</code> call), <code>include</code> doesn&#39;t have the same &quot;context&quot; as <code>parentfile</code>, which would lead to <code>path</code> being interpreted as non-existing (unless <code>path</code> is an absolute path). So when parsing testsets, <code>ReTest</code> prepends the directory name of <code>parentfile</code> to <code>path</code>.</p><p>The important point is that <code>include</code> is executed at <code>retest</code>-time; if the included file defines other <code>@testset</code> expressions, this will define new testsets in the enclosing module, but these won&#39;t be run immediately; upon a new <code>retest()</code> invocation, these new testsets will be run, but the old one too (the one containing <code>include</code>), which will redefine included testsets. This is brittle, and it&#39;s recommended to not include, within testsets, files defining other testsets.</p><h2 id="Switching-from-Test-to-ReTest"><a class="docs-heading-anchor" href="#Switching-from-Test-to-ReTest">Switching from <code>Test</code> to <code>ReTest</code></a><a id="Switching-from-Test-to-ReTest-1"></a><a class="docs-heading-anchor-permalink" href="#Switching-from-Test-to-ReTest" title="Permalink"></a></h2><p>When used in a package <code>MyPackage</code>, the recommended way to organize test code is as follows:</p><ol><li>replace <code>using Test</code> by <code>using ReTest</code> in the &quot;runtests.jl&quot; file (and in all other test files having <code>using Test</code>)</li><li>wrap the whole content of &quot;runtests.jl&quot; within a module named <code>MyPackageTests</code></li><li>rename &quot;runtests.jl&quot; to &quot;MyPackageTests.jl&quot;</li><li>create a &quot;runtests.jl&quot; file with the following content: <code>include(&quot;MyPackageTests.jl&quot;); MyPackageTests.runtests()</code></li></ol><p>This means that running &quot;runtests.jl&quot; will have the same net effect as before. The &quot;MyPackageTests.jl&quot; file can now be <code>include</code>d in your REPL session (<code>include(&quot;MyPackageTests.jl&quot;)</code>), and you can run all or some of its tests (e.g. <code>MyPackageTests.runtests(&quot;addition&quot;)</code>). This test file can also be included via the <a href="#ReTest.load"><code>ReTest.load</code></a> function or via the <code>load</code> keyword of <code>retest</code>.</p><p>Wrapping the tests in <code>MyPackageTests</code> allows to not pollute <code>Main</code> and keeps the tests of different packages separated. Also, you can modify &quot;MyPackageTests.jl&quot; and re-include it to have the corresponding tests updated (the <code>MyPackageTests</code> module is replaced in <code>Main</code>); otherwise, without a <code>MyPackageTests</code> module, including the file a second time currently triggers a warning for each overwritten toplevel testset.</p><h4 id="Keeping-the-ability-to-use-Test"><a class="docs-heading-anchor" href="#Keeping-the-ability-to-use-Test">Keeping the ability to use <code>Test</code></a><a id="Keeping-the-ability-to-use-Test-1"></a><a class="docs-heading-anchor-permalink" href="#Keeping-the-ability-to-use-Test" title="Permalink"></a></h4><p>One might want to have the possibility to use either <code>Test</code> or <code>ReTest</code> depending on the context. Reasons to still use <code>Test</code> include:</p><ul><li>when running <code>retest</code> for the first time in a Julia session, more code has to be compiled than when running tests with <code>Test</code>, so in the case of running the whole test suite, few seconds can be spared (although using <code>ReTest</code> in parallel mode would generally compensate for this);</li><li><code>ReTest</code> is not yet a fully mature and battle tested package, so you might want to not rely exclusively on it, e.g. for C.I.</li></ul><p>An alternate way to organize the test files is as follows, assuming <code>using Test</code> is only present in &quot;runtests.jl&quot;:</p><ol><li>remove <code>using Test</code> from &quot;runtests.jl&quot;</li><li>rename &quot;runtests.jl&quot; to &quot;tests.jl&quot;</li><li>create a &quot;MyPackageTests.jl&quot; file with the following content:<pre><code class="language-julia">module MyPackageTests
using ReTest
include(&quot;tests.jl&quot;)
end</code></pre></li><li>create a &quot;runtests.jl&quot; file with the following content:<pre><code class="language-julia">using Test
include(&quot;tests.jl&quot;)</code></pre></li></ol><p>That way, <code>include(&quot;test/runtests.jl&quot;)</code> or <code>Pkg.test()</code> will run tests using <code>Test</code>, while <code>include(&quot;test/MyPackageTests.jl&quot;); MyPackageTests.runtests()</code> will use <code>ReTest</code>.</p><h2 id="Filtering"><a class="docs-heading-anchor" href="#Filtering">Filtering</a><a id="Filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering" title="Permalink"></a></h2><p>Most of the time, filtering with a simple string is likely to be enough. For example, in</p><pre><code class="language-julia">@testset &quot;a&quot; begin
    @test true
    @testset &quot;b&quot; begin
    end
    @testset &quot;c&quot; begin
    end
end</code></pre><p>running <code>retest(M, &quot;a&quot;)</code> will run everything, <code>retest(M, &quot;b&quot;)</code> will run <code>@test true</code> and <code>@testset &quot;b&quot;</code> but not <code>@testset &quot;c&quot;</code>. Note that if you want to run <code>@testset &quot;b&quot;</code>, there is no way to not run <code>@test true</code> in <code>@testset &quot;a&quot;</code>; so if it was an expensive test to run, instead of <code>@test true</code>, it could be useful to wrap it in its own testset, so that it can be filtered out.</p><h2 id="Running-tests-in-parallel-with-Distributed"><a class="docs-heading-anchor" href="#Running-tests-in-parallel-with-Distributed">Running tests in parallel with <code>Distributed</code></a><a id="Running-tests-in-parallel-with-Distributed-1"></a><a class="docs-heading-anchor-permalink" href="#Running-tests-in-parallel-with-Distributed" title="Permalink"></a></h2><p>Currently, the tests are automatically run in parallel whenever there are multiple workers, which have to be set manually. Running the tests looks like:</p><pre><code class="language-julia">using Distributed
addprocs(2)
@everywhere include(&quot;test/MyPackageTests.jl&quot;)
MyPackageTests.runtests()</code></pre><p>If the test code doesn&#39;t use <code>ReTest</code> (cf. <a href="#Working-with-test-files-which-use-Test">Working with test files which use <code>Test</code></a>), this can be done as follows:</p><pre><code class="language-julia">using Distributed
addprocs(2)
using ReTest
@everywhere begin
    using ReTest, MyPackage
    ReTest.hijack(MyPackage)
end
MyPackageTests.runtests()</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>As was already mentioned, testset-for iterators are evaluated at load time in the enclosing module, but this currently happens only in the main process. This can lead to unexpected errors when the package was written without a <code>Distributed</code> use-case in mind.</p><p>For example, say the package defines a constant singleton object <code>X</code> which is normally equal to itself (because <code>X === X</code>). But if <code>X</code> is assigned to a testset-for loop variable <code>x</code>, it will be the one from the main process, so within the testset-for, a test like <code>x == X</code> might fail because <code>X</code> refers to the singleton object defined in another process; a solution in this case could be to define explicitly <code>==</code> for objects of the type of <code>X</code>.</p></div></div><p>It should be relatively easy to support threaded execution of testsets (it was actually implemented at one point). But it often happens that compiling package code and testset code (which currently is not threaded) takes quite more time than actually running the code, in which case using <code>Distributed</code> has more tangible benefits.</p><h2 id="Working-with-Revise"><a class="docs-heading-anchor" href="#Working-with-Revise">Working with <code>Revise</code></a><a id="Working-with-Revise-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-Revise" title="Permalink"></a></h2><p>When <code>Revise</code> is loaded and a testset is updated, <code>ReTest</code> will observe that a new testset is added with the same description as a previously existing one, which is then overwritten. This works only if the description is not modified, otherwise both the old and new versions of the testset will co-exist.</p><p>For testsets in a &quot;script&quot; loaded with <code>includet</code>, e.g. those in a &quot;test/MyPackageTests.jl&quot; file, you can request <code>Revise</code> to &quot;load&quot; the updated testsets by putting <code>__revise_mode__ = :eval</code> in the enclosing module.</p><p>When files are included recursively, plain <code>includet</code> won&#39;t work (it is currently documented to be &quot;deliberately non-recursive&quot;). There are three work-arounds, of which the first is recommended:</p><ol><li>load <code>MyPackageTests</code> as a module, i.e. via <code>using MyPackageTests</code> instead of <code>include(&quot;test/MyPackageTests.jl&quot;)</code> (this might involve updating your <code>LOAD_PATH</code> to include &quot;test/&quot; and making sure the required packages are found)</li><li>load <code>MyPackageTests</code> via <a href="#ReTest.load"><code>ReTest.load(MyPackage, revise=true)</code></a>, but this works only in &quot;simple enough&quot; situations</li><li>use the <a href="https://github.com/timholy/Revise.jl/issues/518#issuecomment-667097500">following <code>recursive_includet</code></a> function instead of <code>includet</code>:</li></ol><pre><code class="language-julia">function recursive_includet(filename)
    already_included = copy(Revise.included_files)
    includet(filename)
    newly_included = setdiff(Revise.included_files, already_included)
    for (mod, file) in newly_included
        Revise.track(mod, file)
    end
end</code></pre><h2 id="Working-with-test-files-which-use-Test"><a class="docs-heading-anchor" href="#Working-with-test-files-which-use-Test">Working with test files which use <code>Test</code></a><a id="Working-with-test-files-which-use-Test-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-test-files-which-use-Test" title="Permalink"></a></h2><p>It&#39;s sometimes possible to use <code>ReTest</code> features on a test code base which uses <code>Test</code>, without modifications:</p><ul><li>if you have a package <code>Package</code>, you can try <code>ReTest.hijack(Package)</code>, which will define a <code>PackageTests</code> module when successful, on which you can call <code>retest</code>. To have <code>Revise</code> track changes to test files, use <code>ReTest.hijack(Package, revise=true)</code>.</li><li>if you have a test file <code>&quot;testfile.jl&quot;</code>, try <code>ReTest.hijack(&quot;testfile.jl&quot;)</code> (this will define a fresh module like above).</li><li><code>Base</code> and standard library modules can also be passed to <code>ReTest.hijack</code> (corresponding tests are loaded via the lower level <a href="#ReTest.hijack_base"><code>ReTest.hijack_base</code></a> function).</li></ul><article class="docstring"><header><a class="docstring-binding" id="ReTest.hijack" href="#ReTest.hijack"><code>ReTest.hijack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ReTest.hijack(source, [modname];
              parentmodule::Module=Main, lazy=false, testset::Bool=false,
              [revise::Bool])</code></pre><p>Given test files defined in <code>source</code> using the <code>Test</code> package, try to load them by replacing <code>Test</code> with <code>ReTest</code>, wrapping them in a module <code>modname</code> defined within <code>parentmodule</code>. If successful, the newly created module <code>modname</code> is returned and <code>modname.runtests()</code> should be callable.</p><p>If <code>source::AbstractString</code>, then it&#39;s interpreted as the top level test file (possibly including other files), and <code>modname</code> defaults to a name based on <code>basename(source)</code>.</p><p>If <code>source::Module</code>, then it&#39;s interpreted as the name of a package, and the &quot;test/runtests.jl&quot; file from this package is loaded. In this case, <code>modname</code> defaults to <code>Symbol(source, :Tests)</code>.</p><p>The current procedure is as follows:</p><ol><li>replace toplevel <code>using Test</code> occurrences by <code>using ReTest</code> (<code>using</code> can have multiple arguments);</li><li>apply recursively these two rules:<ul><li>for all <code>include</code>d files, provided the <code>include</code> statement is at the toplevel, or nested within these toplevel constructs: <code>begin</code>, <code>let</code>, <code>for</code>, <code>while</code>, <code>if</code>, <code>try</code>;</li><li>on the content of all included modules.</li></ul></li></ol><p>When <code>source</code> is <code>Base</code> or a standard library module, a slightly different mechanism is used to find test files (which can contain e.g. non-toplevel <code>include</code>s), i.e. <code>ReTest.hijack_base</code> is used underneath.</p><p><strong><code>lazy</code> keyword</strong></p><p>The <code>lazy</code> keyword specifies whether some toplevel expressions should be skipped:</p><ul><li><code>false</code> means nothing is skipped;</li><li><code>true</code> means toplevel <code>@test*</code> macros are removed, as well as those defined within these toplevel (but possible nested) blocks: <code>begin</code>, <code>let</code>, <code>for</code>, <code>while</code>, <code>if</code>, <code>try</code>;</li><li><code>:brutal</code> means toplevel <code>@test*</code> macros are removed, as well as toplevel <code>begin</code>, <code>let</code>, <code>for</code> or <code>if</code> blocks.</li></ul><p><strong><code>testset</code> keyword</strong></p><p>The <code>testset</code> keyword can help to handle the case where <code>@testset</code>s contain <code>include</code> expressions (at the &quot;toplevel&quot; of the testset), like in the following example:</p><pre><code class="language-julia">@testset &quot;parent&quot; begin
    @test true
    include(&quot;file_with_other_testsets.jl&quot;)
end</code></pre><p>This works well with <code>Test</code> because testsets are run immediately, as well as testsets contained in the included files, which are also recognized as children of the testset which include them. With <code>ReTest</code>, the <code>include</code> expressions would be evaluated only when the parent testsets are run, so that included testsets are not run themselves, but only &quot;declared&quot;.</p><p>It the <code>testset</code> keyword is <code>true</code>, <code>hijack</code> inspects <code>@testset</code> expressions and puts <code>include</code> expressions outside of the testset. This is not ideal, but at least allows <code>ReTest</code> to know about all the testsets right after the call to <code>hijack</code>, and to not declare new testsets when parent testsets are run.</p><p><strong><code>revise</code> keyword</strong></p><p>The <code>revise</code> keyword specifies whether <code>Revise</code> should be used to track the test files (in particular the testsets). If <code>true</code>, <code>Revise</code> must be loaded beforehand in your Julia session. Note that this might be brittle and not work in all cases. <code>revise</code> defaults to <code>true</code> when <code>Revise</code> is loaded, and to <code>false</code> otherwise.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>This function requires at least Julia 1.5.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/ecf4624849d1e7b5edb9ee7b99e9f37f19a2a8a8/src/hijack.jl#L105-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ReTest.hijack_base" href="#ReTest.hijack_base"><code>ReTest.hijack_base</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hijack_base(tests, [modname];
            parentmodule::Module=Main, lazy=false, [revise::Bool])</code></pre><p>Similar to <code>ReTest.hijack</code>, but specifically for <code>Base</code> and stdlib tests. <code>tests</code> speficies which test files should be loaded, in the exact same format as <code>Base.runtests</code> (i.e. it uses the same <code>choosetests</code> function to select the tests).</p><p>Tests corresponding to a &quot;test/[somedir/]sometest.jl&quot; file are loaded in the <code>BaseTests.[somedir.]sometest</code> module (if <code>sometest</code> is defined in <code>Base</code>, then <code>sometest_</code> is used instead).</p><p>Tests corresponding to a standard library <code>Lib</code> are loaded in the <code>StdLibTests.Lib_</code> module. When there are &quot;testgroups&quot;, submodules are created accordingly.</p><p>If <code>modname</code> is specified (experimental), this will be the name of the module in which testsets are defined; passing <code>modname</code> is allowed only when all the loaded tests would otherwise be defined in the same second top-most module, the one under <code>BaseTests</code> or <code>StdLibTests</code> (e.g. <code>somedir</code> if any, or <code>sometest</code> otherwise, or <code>Lib_</code>). This unique module is then named <code>modname</code>, and not enclosed within <code>BaseTests</code> or <code>StdLibTests</code>.</p><p>The <code>lazy</code> and <code>revise</code> keywords have the same meaning as in <a href="#ReTest.hijack"><code>ReTest.hijack</code></a>. Depending on the value of <code>lazy</code>, some test files are skipped when they are known to fail.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>This function requires at least Julia 1.5.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/ecf4624849d1e7b5edb9ee7b99e9f37f19a2a8a8/src/hijack.jl#L366-L396">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 8 June 2021 12:35">Tuesday 8 June 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
