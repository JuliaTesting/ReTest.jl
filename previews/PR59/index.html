<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ReTest.jl · ReTest.jl</title><meta name="title" content="ReTest.jl · ReTest.jl"/><meta property="og:title" content="ReTest.jl · ReTest.jl"/><meta property="twitter:title" content="ReTest.jl · ReTest.jl"/><meta name="description" content="Documentation for ReTest.jl."/><meta property="og:description" content="Documentation for ReTest.jl."/><meta property="twitter:description" content="Documentation for ReTest.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ReTest.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>ReTest.jl</a><ul class="internal"><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#Quick-start"><span>Quick start</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li><li><a class="tocitem" href="#Caveats"><span>Caveats</span></a></li><li><a class="tocitem" href="#Switching-from-Test-to-ReTest"><span>Switching from <code>Test</code> to <code>ReTest</code></span></a></li><li><a class="tocitem" href="#Filtering"><span>Filtering</span></a></li><li><a class="tocitem" href="#Running-tests-in-parallel-with-Distributed"><span>Running tests in parallel with <code>Distributed</code></span></a></li><li><a class="tocitem" href="#Working-with-Revise"><span>Working with <code>Revise</code></span></a></li><li><a class="tocitem" href="#Working-with-test-files-which-use-Test"><span>Working with test files which use <code>Test</code></span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>ReTest.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ReTest.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaTesting/ReTest.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaTesting/ReTest.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ReTest.jl"><a class="docs-heading-anchor" href="#ReTest.jl">ReTest.jl</a><a id="ReTest.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ReTest.jl" title="Permalink"></a></h1><p><code>ReTest</code> is a testing framework for Julia allowing:</p><ol><li><p>Defining tests in source files, whose execution is deferred and triggered on demand.</p><p>This is useful when one likes to have definitions of methods and corresponding tests close to each other. This is also useful for code which is not (yet) organized as a package, and where one doesn&#39;t want to maintain a separate set of files for tests.</p></li><li><p>Filtering run testsets with a <code>Regex</code>, which is matched against the descriptions of testsets.</p><p>This is useful for running only part of the test suite of a package. For example, if you made a change related to addition, and included &quot;addition&quot; in the description of the corresponding testsets, you can easily run only these tests.</p><p>Note that a <a href="https://github.com/JuliaLang/julia/pull/33672">pull request</a> exists in the Julia repository to implement regex-filtering for <code>Test.@testset</code>.</p></li></ol><p>A couple more features are also enabled, like shuffling the order in which the testsets are run, or running testsets in parallel (via <code>Distributed</code>).</p><p><code>ReTest</code> is mostly backward-compatible with <code>Test</code>, i.e. minimal change to test files is necessary in order to switch to <code>ReTest</code>; it&#39;s often even possible to use <code>ReTest</code> features without changing a line, e.g. on Julia&#39;s <code>Base</code>/stdlib tests), cf. <a href="#Working-with-test-files-which-use-Test">Working with test files which use <code>Test</code></a>.</p><p><code>ReTest</code> is still at an early stage of development. If you like to use it for your packages, it&#39;s recommended to <a href="#Keeping-the-ability-to-use-Test">keep your tests compatible with <code>Test</code></a>, so that they can be run through both frameworks (e.g. using <code>ReTest</code> interactively and <code>Test</code> in C.I.).</p><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><p>The exported <a href="#InlineTest.@testset"><code>ReTest.@testset</code></a> macro can be used as a direct replacement for <code>Test.@testset</code> (with limitations, <a href="#Caveats">see below</a>), and <code>retest()</code> has to be called for the tests to be executed. See <a href="#InlineTest.retest"><code>retest</code></a>&#39;s docstrings for more details. Moreover, <code>ReTest</code> re-exports (almost) all exported symbols from <code>Test</code>, so there should not be any need to import <code>Test</code> together with <code>ReTest</code>.</p><p>When using <code>@testset</code> &quot;inline&quot;, i.e. within the source-code of a package, one can use the <code>InlineTest</code> package instead of <code>ReTest</code>, which only defines the strict minimum and also exports <code>@testset</code>, and therefore loads faster (even if <code>ReTest</code> itself loads fast, it can be desirable to have an even lighter dependency). But <code>ReTest</code> still has to be loaded (as a &quot;test&quot; dependency) in order to call <code>retest</code>.</p><p>Finally, for convenience, <code>ReTest.@testset</code> also implicitly defines a <code>runtests</code> function within the enclosing module (and within all recursive parent modules), say <code>M</code>, such that <code>M.runtests(...)</code> is equivalent to calling <code>retest(M, ...)</code>.</p><h2 id="Quick-start"><a class="docs-heading-anchor" href="#Quick-start">Quick start</a><a id="Quick-start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-start" title="Permalink"></a></h2><p>Both <code>ReTest</code> and <code>InlineTest</code> are registered packages and can be installed the usual way. Let&#39;s create a package <code>MyPackage</code>, which is initially a single file located in a directory known to <code>LOAD_PATH</code>. We want to test its <code>greet</code> function, by writing tests directly in the same file; this is a use-case for <code>InlineTest</code>, which loads faster than <code>ReTest</code>:</p><pre><code class="language-julia hljs"># MyPackage.jl file

module MyPackage
using InlineTest

greet() = &quot;Hello World!&quot;

@testset &quot;greet&quot; begin
    @test greet() == &quot;Hello World!&quot;
end

end # module</code></pre><p>Now, in a Julia session, we load <code>MyPackage</code> and <code>ReTest</code> (needed to actually run the tests):</p><pre><code class="language-julia hljs">julia&gt; using MyPackage, ReTest

julia&gt; MyPackage.runtests()
             Pass
greet    |      1</code></pre><p>Suppose now that we organize <code>MyPackage</code> as a standard package, with a proper &quot;runtests.jl&quot; file. We can still keep testsets within &quot;MyPackage.jl&quot;, while adding more thorough tests in the &quot;test&quot; folder, which can contain two files, &quot;runtests.jl&quot; and &quot;MyPackageTests.jl&quot;:</p><pre><code class="language-julia hljs"># MyPackage/test/runtests.jl file

using ReTest, MyPackage
include(&quot;MyPackageTests.jl&quot;)

# when including this file (e.g. with `Pkg.test`), all the tests
# in both modules will be run:

retest(MyPackage, MyPackageTests)</code></pre><pre><code class="language-julia hljs"># MyPackage/test/MyPackageTests.jl file

module MyPackageTests
using MyPackage, ReTest

@testset &quot;more greet&quot; begin
    @testset &quot;concatenation&quot; begin
        @test MyPackage.greet()^2 == &quot;Hello World!Hello World!&quot;
    end
end

@testset &quot;stuff&quot; begin
    @test true
end

end # module</code></pre><p>We can now load tests either via <code>using MyPackageTests</code>, if <code>LOAD_PATH</code> is configured appropriately, or via <code>include</code>, and run whichever tests we want:</p><pre><code class="language-julia hljs">julia&gt; include(&quot;test/MyPackageTests.jl&quot;);

julia&gt; using ReTest # to use the `retest` function

julia&gt; retest(dry=true, verbose=2) # just list tests, showing nested ones
MyPackage
1| greet

Main.MyPackageTests
1| more greet
2|   concatenation
3| stuff

julia&gt; retest(&quot;greet&quot;, verbose=2) # run only tests related to `greet()`
                         Pass
MyPackage:
  greet              |      1

Main.MyPackageTests:
  more greet         |      1
    concatenation    |      1

Overall              |      2

julia&gt; MyPackageTests.runtests(3) # run only testset with ID 3 in MyPackageTests
                          Pass
3| stuff              |      1</code></pre><p>Here it is for basic usage!</p><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><ul><li><a href="#Defining-tests">Defining tests</a></li><li><a href="#Running-tests">Running tests</a></li><li><a href="#Loading-tests">Loading tests</a></li><li><a href="#Filtering-tests">Filtering tests</a></li></ul><h3 id="Defining-tests"><a class="docs-heading-anchor" href="#Defining-tests">Defining tests</a><a id="Defining-tests-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-tests" title="Permalink"></a></h3><ul><li><a href="#InlineTest.@testset"><code>@testset</code></a></li><li><a href="#InlineTest.@testset_macro"><code>@testset_macro</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InlineTest.@testset" href="#InlineTest.@testset"><code>InlineTest.@testset</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@testset args...</code></pre><p>Similar to <code>Test.@testset args...</code>, but the contained tests are not run immediately, and are instead stored for later execution, triggered by <a href="#InlineTest.retest"><code>retest()</code></a> or <code>runtests()</code>.</p><p>Besides the <code>@testset</code> body (last argument) and a description string, arguments of <code>@testset</code> can be:</p><ul><li>the <code>verbose</code> option, with a <em>literal</em> boolean value (e.g. <code>verbose=true</code>)</li><li>a literal symbol, serving as a label which can be used for testset filtering (see <a href="#InlineTest.retest"><code>retest</code></a>&#39;s docstring for details). All nested testsets inherit such labels.</li></ul><p>Invocations of <code>@testset</code> can be nested, but qualified invocations of <code>ReTest.@testset</code> can&#39;t.</p><p>A <code>@testset</code> can contain a nested <code>Test.@testset</code>, or call a function which defines a <code>Test.@testset</code>: in this case, the <code>Test.@testset</code> will be run whenever the parent testset is run, but <code>retest</code> won&#39;t know about it: it won&#39;t be taken into account during the filtering phase, and won&#39;t be printed in dry mode.</p><p>Internally, <code>@testset</code> expressions are converted to an equivalent of <code>Test.@testset</code> at execution time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/de079491b92fa5fc88bde37840b5f3900114ee6d/InlineTest/src/InlineTest.jl#L48-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InlineTest.@testset_macro" href="#InlineTest.@testset_macro"><code>InlineTest.@testset_macro</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@testset_macro @mac</code></pre><p>Declare <code>@mac</code> as a macro which must be expanded statically by <code>retest</code> so that contained <code>@testset</code>s can be discovered.</p><p>Consider this pattern with <code>Test</code> which factors out testsets in a function:</p><pre><code class="language-julia hljs">using Test

function test_iseven(x)
    @testset &quot;iseven $x&quot; begin
        @test iseven(x)
    end
end

@testset &quot;test $x&quot; for x=2:2:4
    test_iseven(x)
end</code></pre><p>This doesn&#39;t translate directly with <code>ReTest</code>, as the call to <code>test_iseven</code> will be performed at run-time, and will end up declaring a new <code>@testset &quot;iseven $x&quot;</code> at toplevel (this is a problem similar to having <code>include</code> inside testsets). So on the first run of <code>retest()</code>, no <code>@test</code> is run, and on the second one, it fails because <code>x</code> is not defined at global scope.</p><p>The alternative is to turn <code>test_iseven</code> into a macro and declare it with <code>@testset_macro</code>:</p><pre><code class="language-julia hljs">using ReTest

macro test_iseven(x)
    quote
        @testset &quot;iseven $($x)&quot; begin
            @test iseven($x)
        end
    end
end

@testset_macro @test_iseven

@testset &quot;test $x&quot; for x=2:2:4
    @test_iseven(x)
end</code></pre><p>Then, running <code>retest(&quot;iseven&quot;, verbose=2)</code> gives:</p><pre><code class="nohighlight hljs">                    Pass
test 2          |      1
  iseven 2      |      1
test 4          |      1
  iseven 4      |      1
Main            |      2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/de079491b92fa5fc88bde37840b5f3900114ee6d/InlineTest/src/InlineTest.jl#L119-L175">source</a></section></article><h3 id="Running-tests"><a class="docs-heading-anchor" href="#Running-tests">Running tests</a><a id="Running-tests-1"></a><a class="docs-heading-anchor-permalink" href="#Running-tests" title="Permalink"></a></h3><ul><li><a href="#InlineTest.retest"><code>retest</code></a></li><li><a href="#ReTest.watch"><code>watch</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="InlineTest.retest" href="#InlineTest.retest"><code>InlineTest.retest</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">retest(mod..., pattern...;
       dry::Bool=false, stats::Bool=false, verbose::Real=true,
       [id::Bool], shuffle::Bool=false, recursive::Bool=true,
       static::Union{Bool,Nothing}=nothing, dup::Bool=false,
       load::Bool=false, seed::Union{Integer,Bool}=false,
       marks::Bool=true, tag=[], spin::Bool=true)</code></pre><p>Run tests declared with <a href="#InlineTest.@testset"><code>@testset</code></a> blocks, within modules <code>mod</code> if specified, or within all currently loaded modules otherwise. Filtering <code>pattern</code>s can be specified to run only a subset of the tests.</p><p><strong>Keywords</strong></p><ul><li>If <code>dry</code> is <code>true</code>, don&#39;t actually run the tests, just print the descriptions of the testsets which would (presumably) run.</li><li>If <code>stats</code> is <code>true</code>, print some time/memory statistics for each testset.</li><li>If specified, <code>verbose</code> must be an integer or <code>Inf</code> indicating the nesting level of testsets whose results must be printed (this is equivalent to adding the <code>verbose=true</code> annotation to corresponding testsets); the default behavior (<code>true</code> or <code>1</code>) corresponds to printing the result of top-level testsets.</li><li>If <code>id</code> is <code>true</code>, a unique (per module) integer ID is printed next to each testset, which can be used for filtering. The default value of <code>id</code> depends on other options.</li><li>If <code>shuffle</code> is <code>true</code>, shuffle the order in which top-level testsets within a given module are run, as well as the list of passed modules.</li><li>If <code>recursive</code> is <code>true</code>, the tests for all the recursive submodules of the passed modules <code>mod</code> are also run.</li><li>The <code>static</code> keyword controls testsets filtering: if <code>true</code>, only testsets which are known to match &quot;statically&quot; the passed patterns, i.e. at filtering time, are run. See docstring of <a href="#ReTest.interpolated"><code>interpolated</code></a> for more details.</li><li>If <code>dup</code> is <code>true</code>, multiple toplevel testsets can have the same description. If <code>false</code>, only the last testset of a &quot;duplicate group&quot; is kept. The default is <code>false</code> in order to encourage having unique descriptions (useful for filtering) but also and mostly to play well with <code>Revise</code>. This keyword applies only to newly added testsets since the last run.</li><li>When <code>load</code> is <code>true</code>, for each package module <code>Mod</code> which is selected, <code>retest</code> attempts to also select a corresponding <code>Main.ModTests</code> module with the same pattern specification, unless such module is already explicitly passed as an argument. If this test module doesn&#39;t already exist, <code>retest</code> attempts first to include into <code>Main</code> the corresponding test file &quot;test/ModTests.jl&quot; which is assumed, if it exists, to define one or more test modules (typically <code>ModTests</code>); these new test modules are associated to <code>Mod</code> (they inherit its pattern specification as above), and are cached and used again on subsequent invocations.</li><li>If <code>seed</code> is provided, it is used to seed the global RNG before running the tests. As a special case, if <code>seed === false</code> (the default), no seeding is performed, and if <code>seed === true</code>, a seed is chosen randomly.</li><li>When <code>marks</code> and <code>dry</code> are <code>true</code>, &quot;check marks&quot; are printed next to testsets which passed or failed in previous runs, as well as labels.</li><li>The <code>tag</code> keyword allows to tag a testset with labels, encoded as symbols. When <code>tag</code> is a list of symbols, tag all matching testsets with these. When <code>tag</code> is a symbol, tag all matching testsets with it. Instead of a symbol <code>:sym</code>, it&#39;s possible to instead pass <code>not(:sym)</code> in order to remove the <code>:sym</code> label from matching testsets. Currently, <code>tag</code> has an effect only if <code>dry</code> is <code>true</code>.</li><li>When <code>spin</code> is <code>true</code>, the description of the testset being currently executed is shown (if there is only one), as well as a &quot;spinner&quot;. This is disabled when all the available threads/workers are used to run tests (i.e. typically <code>Threads.nthreads()</code> should be greater than <code>1</code> for <code>spin</code> to take effect). Note also that this feature slows down a bit the execution of tests.</li></ul><p>The default values of these keywords can be overriden by defining a dictionary or named tuple within <code>Main</code> called <code>__retest_defaults__</code>, whose keys are symbols. E.g. <code>__retest_defaults__ = (verbose=Inf, spin=false)</code>.</p><p><strong>Filtering</strong></p><p>It&#39;s possible to filter run testsets by specifying one or multiple <code>pattern</code>s. A testset is guaranteed to run only if it &quot;matches&quot; all passed patterns (conjunction). Even if a testset is run, its nested testsets might not run if they don&#39;t match the patterns. Moreover if a testset is run, its enclosing testset, if any, also has to run (although not necessarily exhaustively, i.e. other nested testsets might be filtered out).</p><p>A <code>pattern</code> can be a string, a <code>Regex</code>, an integer, a symbol, an array or a tuple. For a testset to &quot;match&quot; an array, it must match at least one of its elements (disjunction). To match a tuple, it must match all of its elements (conjunction). To match an integer, its ID must be equal to this integer (cf. the <code>id</code> keyword). To match a symbol, it must be tagged with that symbol (label).</p><p>A pattern can also be the &quot;negation&quot; of a pattern, via the <a href="#ReTest.not"><code>not</code></a> function, which allows to exclude testsets from being run. As a special case, the negation of an integer can be expressed as its arithmetic negation, e.g. <code>not(3)</code> is equivalent to <code>-3</code>.</p><p>Patterns can also be created via <a href="#ReTest.reachable"><code>reachable</code></a>, <a href="#ReTest.interpolated"><code>interpolated</code></a> and <a href="#ReTest.depth"><code>depth</code></a>.</p><p><strong><code>Regex</code> filtering</strong></p><p>The &quot;subject&quot; of a testset is the concatenation of the subject of its parent <code>@testset</code>, if any, with <code>&quot;/$description&quot;</code> where <code>description</code> is the testset&#39;s description. For example:</p><pre><code class="language-julia hljs">@testset &quot;a&quot; begin # subject is &quot;/a&quot;
    @testset &quot;b&quot; begin # subject is &quot;/a/b&quot;
    end
    @testset &quot;c$i&quot; for i=1:2 # subjects are &quot;/a/c1&quot; and &quot;/a/c2&quot;
    end
end</code></pre><p>When <code>pattern</code> is a <code>Regex</code>, a testset is guaranteed to run only when its subject matches <code>pattern</code>. Moreover, even if a testset matches (e.g. <code>&quot;/a&quot;</code> above with <code>pattern == r&quot;a$&quot;</code>), its nested testsets might be filtered out if they don&#39;t also match (e.g. <code>&quot;a/b&quot;</code> doesn&#39;t match <code>pattern</code>).</p><p>If a passed <code>pattern</code> is a string, then it is wrapped in a <code>Regex</code> with the &quot;case-insensitive&quot; flag, and must match literally the subjects. This means for example that <code>&quot;a|b&quot;</code> will match a subject like <code>&quot;a|b&quot;</code> or <code>&quot;A|B&quot;</code>, but not like <code>&quot;a&quot;</code> (only in Julia versions &gt;= 1.3; in older versions, the regex is simply created as <code>Regex(pattern, &quot;i&quot;)</code>).</p><p>As a special case, if a string pattern starts with the <code>&#39;-&#39;</code> character, it&#39;s interpreted as the negation of the pattern corresponding to the string with <code>&#39;-&#39;</code> chopped off, e.g. <code>&quot;-abc&quot;</code> is equivalent to <code>not(&quot;abc&quot;)</code>. Unless the string starts with two <code>&#39;-&#39;</code> characters, in which case the first <code>&#39;-&#39;</code> is chopped off, e.g. <code>&quot;--abc&quot;</code> will match subjects such as <code>&quot;123-abc&quot;</code>. To negate such a pattern, just use <code>not</code>, e.g. <code>not(&quot;--abc&quot;)</code>.</p><p><strong>Per-module patterns</strong></p><p>In addition to modules or patterns, positional arguments of <code>retest</code> can also be a pair of the form <code>mod =&gt; pattern</code>: then <code>pattern</code> is used to filter only testsets from <code>mod</code>; if other &quot;standalone&quot; patterns (not attached to a module) are specified, they also conjunctively apply to <code>mod</code>. For example, a call like <code>retest(mod1 =&gt; 1:3, mod2, &quot;x&quot;)</code> is equivalent to <code>retest(mod1 =&gt; (1:3, &quot;x&quot;), mod2 =&gt; &quot;x&quot;)</code>. If <code>recursive</code> is <code>true</code>, <code>pattern</code> is also applied to all recursive submodules <code>sub</code> of <code>mod</code>; if <code>sub</code> is also specified as <code>sub =&gt; subpat</code>, the patterns are merged, i.e. this is equivalent to specifying <code>sub =&gt; (pattern, subpat)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function executes each (top-level) <code>@testset</code> block using <code>eval</code> <em>within</em> the module in which it was written (e.g. <code>mod</code>, when specified).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/de079491b92fa5fc88bde37840b5f3900114ee6d/src/ReTest.jl#L610-L749">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReTest.watch" href="#ReTest.watch"><code>ReTest.watch</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReTest.watch(args...; kwargs...)</code></pre><p>Run <code>retest(args...; kwargs...)</code> repeatedly each time <code>Revise</code> detects file updates. <code>Revise</code> must be loaded beforehand in your Julia session.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This experimental function is not tested and is currently very basic.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/de079491b92fa5fc88bde37840b5f3900114ee6d/src/watch.jl#L1-L9">source</a></section></article><h3 id="Loading-tests"><a class="docs-heading-anchor" href="#Loading-tests">Loading tests</a><a id="Loading-tests-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-tests" title="Permalink"></a></h3><ul><li><a href="#ReTest.load"><code>load</code></a></li><li><a href="#ReTest.hijack"><code>hijack</code></a></li><li><a href="#ReTest.hijack_base"><code>hijack_base</code></a></li></ul><p>Cf. <a href="#Working-with-test-files-which-use-Test">Working with test files which use Test</a> for  <code>hijack</code> and <code>hijack_base</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReTest.load" href="#ReTest.load"><code>ReTest.load</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReTest.load(testpath::AbstractString;
            parentmodule::Module=Main, [revise::Bool])</code></pre><p>Include file <code>testpath</code> into <code>parentmodule</code>. If <code>revise</code> is <code>true</code>, <code>Revise</code>, which must be loaded beforehand in your Julia session, is used to track all recursively included files (in particular testsets). The <code>revise</code> keyword defaults to <code>true</code> when <code>Revise</code> is loaded and <code>VERSION &gt;= v&quot;1.5&quot;</code>, and to <code>false</code> otherwise.</p><p>The point of using this function is when <code>revise</code> is <code>true</code> and in particular when files are included recursively. If <code>revise</code> is false, this is equivalent to <code>parentmodule.include(testpath)</code>, and if there are no recursively included files, this should be equivalent to <code>Revise.includet(testpath)</code>, provided <code>parentmodule == Main</code> and all <code>@testset</code>s defined in <code>testpath</code> are in a module defining  <code>__revise_mode__ = :eval</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>This function requires at least Julia 1.5 when <code>revise</code> is <code>true</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/de079491b92fa5fc88bde37840b5f3900114ee6d/src/hijack.jl#L1-L21">source</a></section><section><div><pre><code class="language-julia hljs">ReTest.load(Mod::Module, testfile::AbstractString=&quot;ModTests.jl&quot;;
            parentmodule::Module=Main, [revise::Bool])</code></pre><p>Given a package <code>Mod</code>, include into <code>parentmodule</code> the corresponding tests from file <code>testfile</code>, which is assumed to be located in the &quot;test&quot; directory of the package. It is expected that a unique new test module is created within <code>parentmodule</code> after the inclusion, which is then returned. Otherwise, the list of all newly created test modules is returned, triggering a warning if it&#39;s empty.</p><p>If <code>revise</code> is <code>true</code>, <code>Revise</code>, which must be loaded beforehand in your Julia session, is used to track the test files (in particular testsets). Note that this might be brittle, and it&#39;s recommended instead to load your test module via <code>using ModTests</code>. The <code>revise</code> keyword defaults to <code>true</code> when <code>Revise</code> is loaded and <code>VERSION &gt;= v&quot;1.5&quot;</code>, and to <code>false</code> otherwise.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>This function requires at least Julia 1.5 when <code>revise</code> is <code>true</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/de079491b92fa5fc88bde37840b5f3900114ee6d/src/hijack.jl#L40-L60">source</a></section></article><h3 id="Filtering-tests"><a class="docs-heading-anchor" href="#Filtering-tests">Filtering tests</a><a id="Filtering-tests-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering-tests" title="Permalink"></a></h3><ul><li><a href="#ReTest.not"><code>not</code></a></li><li><a href="#ReTest.pass"><code>pass</code></a> and <a href="#ReTest.fail"><code>fail</code></a></li><li><a href="#ReTest.reachable"><code>reachable</code></a></li><li><a href="#ReTest.interpolated"><code>interpolated</code></a></li><li><a href="#ReTest.depth"><code>depth</code></a></li><li><a href="#ReTest.iter"><code>iter</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReTest.not" href="#ReTest.not"><code>ReTest.not</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">not(pattern)</code></pre><p>Create an object suitable for filtering testsets (in the <a href="#InlineTest.retest"><code>retest</code></a> function), which &quot;negates&quot; the meaning of <code>pattern</code>: a testset matches <code>not(pattern)</code> if and only if it doesn&#39;t match <code>pattern</code>.</p><p>For example <code>not(&quot;a&quot;)</code> matches any testset whose subject doesn&#39;t contain <code>&quot;a&quot;</code>, and <code>not(1:3)</code> matches all the testsets but the first three of a module.</p><p>If <code>pattern</code> is an integer or a <code>ReTest</code> object (i.e. not a <code>AbstractString</code>, <code>Regex</code>, <code>Tuple</code> or <code>AbstractArray</code>), <code>not(pattern)</code> can be expressed as <code>-pattern</code>.</p><p><code>String</code> patterns can also be negated by prepending <code>&#39;-&#39;</code>, see <a href="#InlineTest.retest"><code>retest</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/de079491b92fa5fc88bde37840b5f3900114ee6d/src/patterns.jl#L202-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReTest.pass" href="#ReTest.pass"><code>ReTest.pass</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pass</code></pre><p>Filtering pattern which matches any testset which already ran successfully. The pattern <code>[pass, fail]</code> matches any testset which already ran.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/de079491b92fa5fc88bde37840b5f3900114ee6d/src/patterns.jl#L519-L524">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReTest.fail" href="#ReTest.fail"><code>ReTest.fail</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fail</code></pre><p>Filtering pattern which matches any testset which already ran with at least one error. The pattern <code>[pass, fail]</code> matches any testset which already ran.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/de079491b92fa5fc88bde37840b5f3900114ee6d/src/patterns.jl#L527-L532">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReTest.reachable" href="#ReTest.reachable"><code>ReTest.reachable</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reachable(pattern)</code></pre><p>Create a filtering pattern which matches any testset matching <code>pattern</code> or whose parent testset, if any, matches <code>reachable(pattern)</code>. In other words, if a testset matches <code>pattern</code>, all its recursive nested testsets will also match.</p><p>When <code>pattern::String</code>, <code>reachable(pattern)</code> has the same effect as <code>pattern</code>, because the subject of a testset is contained in the subjects of all its nested testsets. So <code>reachable</code> is typically useful when <code>pattern</code> is an integer.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; module T
       using ReTest
       @testset &quot;a&quot; verbose=true begin
           @test true
           @testset &quot;b&quot; begin
               @test true
           end
       end
       @testset &quot;c&quot; begin
           @test true
       end
       end;

julia&gt; retest(T, reachable(1), dry=true)
1| a
2|   b

julia&gt; retest(T, not(reachable(1)), dry=true)
3| c</code></pre><p>Note that the algorithm for <code>reachable</code> is currently not optimized, i.e. it will match <code>pattern</code> against all parents of a testset until success, even when this match was already performed earlier (i.e. the result of matching against <code>pattern</code> is not cached).</p><p>Also, in the current implementation, the subject of a parent testset is inferred from the subject of a testset, by chopping off the last component, determined by the last occurrence of <code>&#39;/&#39;</code>. This has two consequences. It will produce incorrect results if the description of a testset contains <code>&#39;/&#39;</code>, and also, with <a href="#ReTest.interpolated"><code>interpolated</code></a> when the subject is &quot;unknown&quot; due to un-interpolated descriptions. Consider the following example:</p><pre><code class="language-julia hljs">julia&gt; module Fail
       using ReTest
       @testset &quot;a&quot; begin
           x = 1
           @testset &quot;b$x&quot; begin
               @testset &quot;c&quot; begin end
           end
       end
       end;

julia&gt; retest(Fail, reachable(1), verbose=9, dry=true)
1| a
2|   &quot;b$(x)&quot;
3|     c

julia&gt; retest(Fail, reachable(interpolated), verbose=9, dry=true)
1| a</code></pre><p>Here, both testsets with id <code>2</code> and <code>3</code> have an unknown subject (at filtering time), which prevents the algorithm to detect that one of their parents (testset <code>1</code>) actually has an &quot;interpolated&quot; description.</p><p>On the other hand, even with these unknown subjects, something like <code>reachable(&quot;a&quot;)</code> would work as expected:</p><pre><code class="language-julia hljs">julia&gt; retest(Fail, reachable(&quot;a&quot;), verbose=9, dry=true)
1| a
2|   &quot;b$(x)&quot;
3|     c

julia&gt; retest(Fail, reachable(&quot;a&quot;), verbose=9, dry=true, static=true)
1| a</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.3</header><div class="admonition-body"><p>This function requires at least Julia 1.3.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/de079491b92fa5fc88bde37840b5f3900114ee6d/src/patterns.jl#L380-L467">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReTest.interpolated" href="#ReTest.interpolated"><code>ReTest.interpolated</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interpolated</code></pre><p>Singleton pattern which matches any testset whose subject can be interpolated &quot;statically&quot;, i.e. at filtering time before testset are actually run. Non-inferrable subjects include those constructed from descriptions containing interpolated values which can&#39;t be known until run time. This pattern has an effect closely related to that of the <code>static</code> keyword of <a href="#InlineTest.retest"><code>retest</code></a>, discussed below, which is probably more generally useful.</p><p><strong>Examples</strong></p><p>Given these testset:</p><pre><code class="language-julia hljs">@testset &quot;outer&quot; verbose=true begin
    @test true
    inner = &quot;inner&quot;
    @testset &quot;$inner&quot; begin
        @test true
    end
end
@testset &quot;other&quot; begin
    @test true
end</code></pre><p>We get:</p><pre><code class="language-julia hljs">julia&gt; retest(&quot;other&quot;, dry=true)
Main
1| outer
2|   &quot;$(inner)&quot;
3| other

julia&gt; retest(&quot;other&quot;, dry=false)
            Pass
outer   |      1
other   |      1
Main    |      2

julia&gt; retest(&quot;other&quot;, dry=true, interpolated)
Main
3| other</code></pre><p>Without <code>interpolated</code>, <code>retest</code> can&#39;t decide at filtering time whether the &quot;inner&quot; testset will run, so must mark the &quot;outer&quot; testset as having to run. At run time, &quot;inner&quot; is not run because it doesn&#39;t match the pattern, but &quot;outer&quot; still had to run to determine this. With the <code>interpolated</code> pattern, &quot;inner&quot; is filtered out and <code>retest</code> selects only testsets which are statically known to have to run.</p><p>So again, <code>interpolated</code> doesn&#39;t have the same effect at filtering time (like when <code>dry=true</code>) and at run time. For example, one can see the list of non-interpolated subjects as follows with <code>dry=true</code>, but not run them (because everything is interpolated at run time):</p><pre><code class="language-julia hljs">julia&gt; retest(not(interpolated), dry=true)
1| outer
2|   &quot;$(inner)&quot;

julia&gt; retest(not(interpolated), dry=false)
            Pass
Main:
  outer |      1</code></pre><p><strong><code>static</code> keyword</strong></p><p>Unlike <code>interpolated</code>, the <code>static</code> keyword of <code>retest</code>, when <code>true</code>, filters out only testsets which can&#39;t be proven to have to run at filtering time, let&#39;s call them &quot;undecidable&quot;. It can have sometimes the same effect as when using <code>interpolated</code>, e.g. <code>retest(&quot;other&quot;, dry=true, static=true)</code> and <code>retest(&quot;other&quot;, dry=true, interpolated)</code> give the same result.</p><p>But in some cases we might want to filter out noisy testsets whose subjects can&#39;t be interpolated, but still include those which are relevant. For example, assume we want to run testsets <code>1</code> and <code>2</code>, while excluding other testsets with uninterpolated subjects:</p><pre><code class="language-julia hljs">julia&gt; retest(1:2, dry=true, interpolated)
Main
1| outer

julia&gt; retest(1:2, dry=true, static=true)
Main
1| outer
2|   &quot;$(inner)&quot;</code></pre><p>The solution with <code>interpolated</code> is not what we want, as we specifically want testset <code>2</code> to run. Given the filtering specifications (<code>1:2</code> here), the filtering algorithm can determine that <code>2</code> should run even though its subject is unknown at this point.</p><p>Given a filtering specification, there are three kind of testsets:</p><ul><li>&quot;undecidable&quot; (see above)</li><li>&quot;match&quot;: they are known statically to have to run</li><li>&quot;nomatch&quot;: they are known statically to not have to run</li></ul><p>The default value of the <code>static</code> keyword is <code>nothing</code>, which means to run testsets which are not known with certainty to not match, i.e. &quot;match&quot; and &quot;undecidable&quot; testsets. As seen above, when <code>static == true</code>, only &quot;match&quot; testsets are run. When <code>static == false</code>, the behavior is the opposite: only &quot;undecidable&quot; testsets are run. Of course, other combinations involving &quot;nomatch&quot; testsets can be had by reversing the filtering pattern via <a href="#ReTest.not"><code>not</code></a>.</p><p>For example, to get the equivalent to the <code>not(interpolated)</code> example above, but with an effect which persists at run time (<code>dry = false</code>), you can use <code>static = false</code> together with the match-all regex pattern <code>r&quot;.*&quot;</code>, which will mark the <code>&quot;inner&quot;</code> testset as &quot;undecidable&quot; (the algorithm inspects slightly patterns just to recognize the simple match-all patterns <code>&quot;&quot;</code> and <code>r&quot;&quot;</code>, but won&#39;t detect that <code>r&quot;.*&quot;</code> would match <code>&quot;$(inner)&quot;</code>):</p><pre><code class="language-julia hljs">julia&gt; retest(r&quot;.*&quot;, static=false, dry=true)
Main
1| outer
2|   &quot;$(inner)&quot;

julia&gt; retest(r&quot;.*&quot;, static=false, dry=false)
               Pass
Main:
  outer    |      2
    inner  |      1</code></pre><p>One example of a rare case where a given testset is not in a single of the above three categories is as follows:</p><pre><code class="language-julia hljs">@testset &quot;a&quot; begin
    x = 2
    @testset &quot;b$(i==1 ? 1 : x)&quot; for i=1:2
        @testset &quot;c&quot; begin
            # subject is &quot;match&quot; at first iteration and
            # &quot;undecidable&quot; at second iteration
            @test true
        end
    end
end</code></pre><p>One thing to understand is that the &quot;identity&quot; of a testset is determined by a given occurrence of the <code>@testset</code> macro. In the example above, for either the patterns &quot;b&quot; or &quot;c&quot;, the two inner testsets are both &quot;match&quot; and &quot;undecidable&quot;. In this case, the filtering algorithm selects a testset to run if at least one iteration would lead to this decision. Here, if <code>static=true</code> the first iteration would run, and if <code>static=false</code> the second iteration would run. This results in the same selection whatever the value of <code>static</code> is.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/de079491b92fa5fc88bde37840b5f3900114ee6d/src/patterns.jl#L223-L376">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReTest.depth" href="#ReTest.depth"><code>ReTest.depth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">depth(d::Integer)</code></pre><p>Create a pattern which matches testsets at &quot;depth&quot; <code>d</code>. Toplevel testsets have depth <code>1</code>, their direct children (nested testsets) depth <code>2</code>, and so on.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; module Depth
       using ReTest
       @testset &quot;1&quot; begin
           @testset &quot;2&quot; begin
               @testset &quot;3&quot; begin end
           end
           @testset &quot;4&quot; begin end
       end
       end;

julia&gt; Depth.runtests(dry=true, verbose=3, depth(2))
1| 1
2|   2
4|   4

julia&gt; Depth.runtests(dry=true, verbose=3, depth(3))
1| 1
2|   2
3|     3

julia&gt; Depth.runtests(dry=true, verbose=3, reachable(depth(2)))
1| 1
2|   2
3|     3
4|   4

julia&gt; Depth.runtests(dry=true, verbose=3, depth.(2:3))
1| 1
2|   2
3|     3
4|   4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/de079491b92fa5fc88bde37840b5f3900114ee6d/src/patterns.jl#L474-L516">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReTest.iter" href="#ReTest.iter"><code>ReTest.iter</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iter(i::Integer)</code></pre><p>Filtering pattern which matches only the <code>i</code>-th iteration of a testset-for. A non-for testset is considered to have a unique iteration.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This is very experimental, not tested, and likely to be removed in a future version.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/de079491b92fa5fc88bde37840b5f3900114ee6d/src/patterns.jl#L535-L544">source</a></section></article><h2 id="Caveats"><a class="docs-heading-anchor" href="#Caveats">Caveats</a><a id="Caveats-1"></a><a class="docs-heading-anchor-permalink" href="#Caveats" title="Permalink"></a></h2><p><code>ReTest.@testset</code> comes with a couple of caveats/limitations, some of which should be fixable:</p><ul><li><p>Toplevel testsets (which are not nested within other testsets), when run, are <code>eval</code>ed at the toplevel of their parent module, which means that they can&#39;t depend on local variables for example.</p></li><li><p>&quot;testsets-for&quot; (<code>@testset &quot;description&quot; for ...</code>), when run, imply <code>eval</code>ing their loop variables at the toplevel of their parent module; this implies that iteration expressions shouldn&#39;t depend on local variables (otherwise, the testset subject usually can&#39;t be known statically and the testset can&#39;t be filtered out with a <code>Regex</code>).</p></li><li><p>Testsets can not be &quot;custom testsets&quot; (cf. <code>Test</code> documentation).</p></li><li><p>Nested testsets can&#39;t be &quot;qualified&quot; (i.e. written as <code>ReTest.@testset</code>).</p></li><li><p>Regex filtering logic might improve in future versions, which means that with the same regex, less tests might be run (or more!). See <a href="#InlineTest.retest"><code>retest</code></a>&#39;s docstring to know which testsets are guaranteed to run.</p></li><li><p>Descriptions of testsets must be unique within a module, otherwise they are overwritten and a warning is issued, unless <code>Revise</code> is loaded; the reason is the current implemented heuristic to allow <code>Revise</code> do its magic.</p></li><li><p>There is not yet a good solution to factor out testsets into functions called within other testsets; a work-around is to use <a href="#InlineTest.@testset_macro"><code>@testset_macro</code></a>, or to use only the <code>@test</code> and <code>@test_*</code> macros within these functions.</p></li><li><p>Interrupting running testsets with Control-C sometimes doesn&#39;t work well, because of the use of multiple tasks in <code>retest</code>. There can also be usability annoyances when some tests are failing. This will hopefully be fixed <em>soon</em>.</p></li></ul><h4 id="Including-files-from-within-testsets"><a class="docs-heading-anchor" href="#Including-files-from-within-testsets">Including files from within testsets</a><a id="Including-files-from-within-testsets-1"></a><a class="docs-heading-anchor-permalink" href="#Including-files-from-within-testsets" title="Permalink"></a></h4><p>TLDR: don&#39;t use <code>include(file)</code> within testsets when <code>file</code> defines other testsets.</p><p>There is limited support for <code>include(path)</code> expressions within testsets: all what <code>ReTest</code> does is to adjust the <code>path</code> according to the location of the containing file <code>parentfile</code>. This is necessary, because <code>include</code> is not run immediately when that file is evaluated; when the given testset is triggered (via a <code>retest</code> call), <code>include</code> doesn&#39;t have the same &quot;context&quot; as <code>parentfile</code>, which would lead to <code>path</code> being interpreted as non-existing (unless <code>path</code> is an absolute path). So when parsing testsets, <code>ReTest</code> prepends the directory name of <code>parentfile</code> to <code>path</code>.</p><p>The important point is that <code>include</code> is executed at <code>retest</code>-time; if the included file defines other <code>@testset</code> expressions, this will define new testsets in the enclosing module, but these won&#39;t be run immediately; upon a new <code>retest()</code> invocation, these new testsets will be run, but the old one too (the one containing <code>include</code>), which will redefine included testsets. This is brittle, and it&#39;s recommended to not include, within testsets, files defining other testsets.</p><h2 id="Switching-from-Test-to-ReTest"><a class="docs-heading-anchor" href="#Switching-from-Test-to-ReTest">Switching from <code>Test</code> to <code>ReTest</code></a><a id="Switching-from-Test-to-ReTest-1"></a><a class="docs-heading-anchor-permalink" href="#Switching-from-Test-to-ReTest" title="Permalink"></a></h2><p>When used in a package <code>MyPackage</code>, the recommended way to organize test code is as follows:</p><ol><li>replace <code>using Test</code> by <code>using ReTest</code> in the &quot;runtests.jl&quot; file (and in all other test files having <code>using Test</code>)</li><li>wrap the whole content of &quot;runtests.jl&quot; within a module named <code>MyPackageTests</code></li><li>rename &quot;runtests.jl&quot; to &quot;MyPackageTests.jl&quot;</li><li>create a &quot;runtests.jl&quot; file with the following content: <code>include(&quot;MyPackageTests.jl&quot;); MyPackageTests.runtests()</code></li></ol><p>This means that running &quot;runtests.jl&quot; will have the same net effect as before. The &quot;MyPackageTests.jl&quot; file can now be <code>include</code>d in your REPL session (<code>include(&quot;MyPackageTests.jl&quot;)</code>), and you can run all or some of its tests (e.g. <code>MyPackageTests.runtests(&quot;addition&quot;)</code>). This test file can also be included via the <a href="#ReTest.load"><code>ReTest.load</code></a> function or via the <code>load</code> keyword of <code>retest</code>.</p><p>Wrapping the tests in <code>MyPackageTests</code> allows to not pollute <code>Main</code> and keeps the tests of different packages separated. Also, you can modify &quot;MyPackageTests.jl&quot; and re-include it to have the corresponding tests updated (the <code>MyPackageTests</code> module is replaced in <code>Main</code>); otherwise, without a <code>MyPackageTests</code> module, including the file a second time currently triggers a warning for each overwritten toplevel testset.</p><h4 id="Keeping-the-ability-to-use-Test"><a class="docs-heading-anchor" href="#Keeping-the-ability-to-use-Test">Keeping the ability to use <code>Test</code></a><a id="Keeping-the-ability-to-use-Test-1"></a><a class="docs-heading-anchor-permalink" href="#Keeping-the-ability-to-use-Test" title="Permalink"></a></h4><p>One might want to have the possibility to use either <code>Test</code> or <code>ReTest</code> depending on the context. Reasons to still use <code>Test</code> include:</p><ul><li>when running <code>retest</code> for the first time in a Julia session, more code has to be compiled than when running tests with <code>Test</code>, so in the case of running the whole test suite, few seconds can be spared (although using <code>ReTest</code> in parallel mode would generally compensate for this);</li><li><code>ReTest</code> is not yet a fully mature and battle tested package, so you might want to not rely exclusively on it, e.g. for C.I.</li></ul><p>An alternate way to organize the test files is as follows, assuming <code>using Test</code> is only present in &quot;runtests.jl&quot;:</p><ol><li>remove <code>using Test</code> from &quot;runtests.jl&quot;</li><li>rename &quot;runtests.jl&quot; to &quot;tests.jl&quot;</li><li>create a &quot;MyPackageTests.jl&quot; file with the following content:<pre><code class="language-julia hljs">module MyPackageTests
using ReTest
include(&quot;tests.jl&quot;)
end</code></pre></li><li>create a &quot;runtests.jl&quot; file with the following content:<pre><code class="language-julia hljs">using Test
include(&quot;tests.jl&quot;)</code></pre></li></ol><p>That way, <code>include(&quot;test/runtests.jl&quot;)</code> or <code>Pkg.test()</code> will run tests using <code>Test</code>, while <code>include(&quot;test/MyPackageTests.jl&quot;); MyPackageTests.runtests()</code> will use <code>ReTest</code>.</p><h2 id="Filtering"><a class="docs-heading-anchor" href="#Filtering">Filtering</a><a id="Filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering" title="Permalink"></a></h2><p>Most of the time, filtering with a simple string is likely to be enough. For example, in</p><pre><code class="language-julia hljs">@testset &quot;a&quot; begin
    @test true
    @testset &quot;b&quot; begin
    end
    @testset &quot;c&quot; begin
    end
end</code></pre><p>running <code>retest(M, &quot;a&quot;)</code> will run everything, <code>retest(M, &quot;b&quot;)</code> will run <code>@test true</code> and <code>@testset &quot;b&quot;</code> but not <code>@testset &quot;c&quot;</code>. Note that if you want to run <code>@testset &quot;b&quot;</code>, there is no way to not run <code>@test true</code> in <code>@testset &quot;a&quot;</code>; so if it was an expensive test to run, instead of <code>@test true</code>, it could be useful to wrap it in its own testset, so that it can be filtered out.</p><h2 id="Running-tests-in-parallel-with-Distributed"><a class="docs-heading-anchor" href="#Running-tests-in-parallel-with-Distributed">Running tests in parallel with <code>Distributed</code></a><a id="Running-tests-in-parallel-with-Distributed-1"></a><a class="docs-heading-anchor-permalink" href="#Running-tests-in-parallel-with-Distributed" title="Permalink"></a></h2><p>Currently, the tests are automatically run in parallel whenever there are multiple workers, which have to be set manually. Running the tests looks like:</p><pre><code class="language-julia hljs">using Distributed
addprocs(2)
@everywhere include(&quot;test/MyPackageTests.jl&quot;)
MyPackageTests.runtests()</code></pre><p>If the test code doesn&#39;t use <code>ReTest</code> (cf. <a href="#Working-with-test-files-which-use-Test">Working with test files which use <code>Test</code></a>), this can be done as follows:</p><pre><code class="language-julia hljs">using Distributed
addprocs(2)
using ReTest
@everywhere begin
    using ReTest, MyPackage
    ReTest.hijack(MyPackage)
end
MyPackageTests.runtests()</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>As was already mentioned, testset-for iterators are evaluated at load time in the enclosing module, but this currently happens only in the main process. This can lead to unexpected errors when the package was written without a <code>Distributed</code> use-case in mind.</p><p>For example, say the package defines a constant singleton object <code>X</code> which is normally equal to itself (because <code>X === X</code>). But if <code>X</code> is assigned to a testset-for loop variable <code>x</code>, it will be the one from the main process, so within the testset-for, a test like <code>x == X</code> might fail because <code>X</code> refers to the singleton object defined in another process; a solution in this case could be to define explicitly <code>==</code> for objects of the type of <code>X</code>.</p></div></div><p>It should be relatively easy to support threaded execution of testsets (it was actually implemented at one point). But it often happens that compiling package code and testset code (which currently is not threaded) takes quite more time than actually running the code, in which case using <code>Distributed</code> has more tangible benefits.</p><h2 id="Working-with-Revise"><a class="docs-heading-anchor" href="#Working-with-Revise">Working with <code>Revise</code></a><a id="Working-with-Revise-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-Revise" title="Permalink"></a></h2><p>When <code>Revise</code> is loaded and a testset is updated, <code>ReTest</code> will observe that a new testset is added with the same description as a previously existing one, which is then overwritten. This works only if the description is not modified, otherwise both the old and new versions of the testset will co-exist.</p><p>For testsets in a &quot;script&quot; loaded with <code>includet</code>, e.g. those in a &quot;test/MyPackageTests.jl&quot; file, you can request <code>Revise</code> to &quot;load&quot; the updated testsets by putting <code>__revise_mode__ = :eval</code> in the enclosing module.</p><p>When files are included recursively, plain <code>includet</code> won&#39;t work (it is currently documented to be &quot;deliberately non-recursive&quot;). There are three work-arounds, of which the first is recommended:</p><ol><li>load <code>MyPackageTests</code> as a module, i.e. via <code>using MyPackageTests</code> instead of <code>include(&quot;test/MyPackageTests.jl&quot;)</code> (this might involve updating your <code>LOAD_PATH</code> to include &quot;test/&quot; and making sure the required packages are found)</li><li>load <code>MyPackageTests</code> via <a href="#ReTest.load"><code>ReTest.load(MyPackage, revise=true)</code></a>, but this works only in &quot;simple enough&quot; situations</li><li>use the <a href="https://github.com/timholy/Revise.jl/issues/518#issuecomment-667097500">following <code>recursive_includet</code></a> function instead of <code>includet</code>:</li></ol><pre><code class="language-julia hljs">function recursive_includet(filename)
    already_included = copy(Revise.included_files)
    includet(filename)
    newly_included = setdiff(Revise.included_files, already_included)
    for (mod, file) in newly_included
        Revise.track(mod, file)
    end
end</code></pre><h2 id="Working-with-test-files-which-use-Test"><a class="docs-heading-anchor" href="#Working-with-test-files-which-use-Test">Working with test files which use <code>Test</code></a><a id="Working-with-test-files-which-use-Test-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-test-files-which-use-Test" title="Permalink"></a></h2><p>It&#39;s sometimes possible to use <code>ReTest</code> features on a test code base which uses <code>Test</code>, without modifications:</p><ul><li>if you have a package <code>Package</code>, you can try <code>ReTest.hijack(Package)</code>, which will define a <code>PackageTests</code> module when successful, on which you can call <code>retest</code>. To have <code>Revise</code> track changes to test files, use <code>ReTest.hijack(Package, revise=true)</code>.</li><li>if you have a test file <code>&quot;testfile.jl&quot;</code>, try <code>ReTest.hijack(&quot;testfile.jl&quot;)</code> (this will define a fresh module like above).</li><li><code>Base</code> and standard library modules can also be passed to <code>ReTest.hijack</code> (corresponding tests are loaded via the lower level <a href="#ReTest.hijack_base"><code>ReTest.hijack_base</code></a> function).</li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReTest.hijack" href="#ReTest.hijack"><code>ReTest.hijack</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReTest.hijack(source, [modname];
              parentmodule::Module=Main, lazy=false, [revise::Bool],
              [include::Symbol], include_functions=[:include])</code></pre><p>Given test files defined in <code>source</code> using the <code>Test</code> package, try to load them by replacing <code>Test</code> with <code>ReTest</code>, wrapping them in a module <code>modname</code> defined within <code>parentmodule</code>. If successful, the newly created module <code>modname</code> is returned and <code>modname.runtests()</code> should be callable.</p><p>If <code>source::AbstractString</code>, then it&#39;s interpreted as the top level test file (possibly including other files), and <code>modname</code> defaults to a name based on <code>basename(source)</code>.</p><p>If <code>source::Module</code>, then it&#39;s interpreted as the name of a package, and the &quot;test/runtests.jl&quot; file from this package is loaded. In this case, <code>modname</code> defaults to <code>Symbol(source, :Tests)</code>.</p><p>The current procedure is as follows:</p><ol><li>replace toplevel <code>using Test</code> occurrences by <code>using ReTest</code> (<code>using</code> can have multiple arguments);</li><li>apply recursively these two rules:<ul><li>for all <code>include</code>d files, provided the <code>include</code> statement is at the toplevel, or nested within these toplevel constructs: <code>begin</code>, <code>let</code>, <code>for</code>, <code>while</code>, <code>if</code>, <code>try</code>;</li><li>on the content of all included modules.</li></ul></li></ol><p>When <code>source</code> is <code>Base</code> or a standard library module, a slightly different mechanism is used to find test files (which can contain e.g. non-toplevel <code>include</code>s), i.e. <code>ReTest.hijack_base</code> is used underneath.</p><p><strong><code>lazy</code> keyword</strong></p><p>The <code>lazy</code> keyword specifies whether some toplevel expressions should be skipped:</p><ul><li><code>false</code> means nothing is skipped;</li><li><code>true</code> means toplevel <code>@test*</code> macros are removed, as well as those defined within these toplevel (but possible nested) blocks: <code>begin</code>, <code>let</code>, <code>for</code>, <code>while</code>, <code>if</code>, <code>try</code>;</li><li><code>:brutal</code> means toplevel <code>@test*</code> macros are removed, as well as toplevel <code>begin</code>, <code>let</code>, <code>for</code> or <code>if</code> blocks.</li></ul><p><strong><code>include</code> keyword</strong></p><p>The <code>include</code> keyword can help to handle the case where <code>@testset</code>s contain <code>include</code> expressions, like in the following example:</p><pre><code class="language-julia hljs">@testset &quot;parent&quot; begin
    @test true
    include(&quot;file_with_other_testsets.jl&quot;)
end</code></pre><p>This works well with <code>Test</code> because testsets are run immediately, as well as testsets contained in the included files, which are also recognized as children of the testset which include them. With <code>ReTest</code>, the <code>include</code> expressions would be evaluated only when the parent testsets are run, so that included testsets are not run themselves, but only &quot;declared&quot;.</p><p>If the <code>include</code> keyword is set to <code>:static</code>, <code>include(...)</code> expressions are evaluated when <code>@testset</code> expressions containing them are parsed, before filtering and before testsets are run. Testsets which are declared (within the same module) as a side effect of <code>include(...)</code> are then inserted in place of the call to <code>include(...)</code>.</p><p>If the <code>include</code> keyword is set to <code>:outline</code>, <code>hijack</code> inspects topelevel <code>@testset</code> expressions and puts toplevel <code>include(...)</code> expressions outside of the containing testset, and should therefore be evaluated immediately. This is not ideal, but at least allows <code>ReTest</code> to know about all the testsets right after the call to <code>hijack</code>, and to not declare new testsets when parent testsets are run.</p><p>The <code>:outline</code> option might be deprecated in the future, and <code>include=:static</code> should generally be preferred. One case where <code>:outline</code> might work better is when the included file defines a submodule: <code>ReTest</code> doesn&#39;t have the concept of a nested testset belonging to a different module than the parent testset, so the best that can be done here is to &quot;outline&quot; such nested testsets; with <code>include=:outline</code>, <code>hijack</code> will &quot;process&quot; the content of such submodules (replace <code>using Test</code> by <code>using ReTest</code>, etc.), whereas with <code>include=:static</code>, the subdmodules will get defined after <code>hijack</code> has returned (on the first call to <code>retest</code> thereafter), so won&#39;t be &quot;processed&quot;.</p><p><strong><code>include_functions</code> keyword</strong></p><p>When the <code>include=:static</code> keyword argument is passed, it&#39;s possible to tell <code>hijack</code> to apply the same treatment to other functions than <code>include</code>, by passing a list a symbols to <code>include_functions</code>. For example, if you defined a custom function <code>custom_include(x)</code> which itself calls out to <code>include</code>, you can pass <code>include_functions=[:custom_include]</code> to <code>hijack</code>.</p><p><strong><code>revise</code> keyword</strong></p><p>The <code>revise</code> keyword specifies whether <code>Revise</code> should be used to track the test files (in particular the testsets). If <code>true</code>, <code>Revise</code> must be loaded beforehand in your Julia session. Note that this might be brittle and not work in all cases. <code>revise</code> defaults to <code>true</code> when <code>Revise</code> is loaded, and to <code>false</code> otherwise.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>This function requires at least Julia 1.5.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/de079491b92fa5fc88bde37840b5f3900114ee6d/src/hijack.jl#L105-L205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReTest.hijack_base" href="#ReTest.hijack_base"><code>ReTest.hijack_base</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hijack_base(tests, [modname];
            parentmodule::Module=Main, lazy=false, [revise::Bool])</code></pre><p>Similar to <code>ReTest.hijack</code>, but specifically for <code>Base</code> and stdlib tests. <code>tests</code> speficies which test files should be loaded, in the exact same format as <code>Base.runtests</code> (i.e. it uses the same <code>choosetests</code> function to select the tests).</p><p>Tests corresponding to a &quot;test/[somedir/]sometest.jl&quot; file are loaded in the <code>BaseTests.[somedir.]sometest</code> module (if <code>sometest</code> is defined in <code>Base</code>, then <code>sometest_</code> is used instead).</p><p>Tests corresponding to a standard library <code>Lib</code> are loaded in the <code>StdLibTests.Lib_</code> module. When there are &quot;testgroups&quot;, submodules are created accordingly.</p><p>If <code>modname</code> is specified (experimental), this will be the name of the module in which testsets are defined; passing <code>modname</code> is allowed only when all the loaded tests would otherwise be defined in the same second top-most module, the one under <code>BaseTests</code> or <code>StdLibTests</code> (e.g. <code>somedir</code> if any, or <code>sometest</code> otherwise, or <code>Lib_</code>). This unique module is then named <code>modname</code>, and not enclosed within <code>BaseTests</code> or <code>StdLibTests</code>.</p><p>The <code>lazy</code> and <code>revise</code> keywords have the same meaning as in <a href="#ReTest.hijack"><code>ReTest.hijack</code></a>. Depending on the value of <code>lazy</code>, some test files are skipped when they are known to fail.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.5</header><div class="admonition-body"><p>This function requires at least Julia 1.5.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaTesting/ReTest.jl/blob/de079491b92fa5fc88bde37840b5f3900114ee6d/src/hijack.jl#L432-L462">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 28 January 2025 09:51">Tuesday 28 January 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
